{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to FunKey! \u00b6 Thank you for choosing the FunKey S ! The FunKey S is the world's smallest foldable retro-gaming console. Because of its foldable design, the FunKey S provides a surprisingly large screen and comfortable key pads while open, but it stays compatible with a keychain usage when closed. Basic operation \u00b6 The FunKey S operation is so straightforward that a 6-year old child should be able to operate it without any user's manual for the most common tasks. But just to make sure you are not missing something, you can find the basic device operation description in the Quickstart section . More advanced features \u00b6 Despite its size, the FunKey S is packed with features, and this documentation will also provide more advanced tips in the Tutorials section . Developers \u00b6 For developers, a full Developer's Guide is included, with both Hardware and Software subsections. Open source files \u00b6 All the software repositories are accessible on our Github . The developer section is a great way to understand its secrets. All the electronic schematics and layouts are accessible here . For mechanical tinkerers or professionals, all the 3D step files are accessible on Grabcad Miscellaenous stuff \u00b6 Last but not least, this documentation would not be complete without a Glossary of terms and an FAQ section for reference.","title":"Overview"},{"location":"#welcome-to-funkey","text":"Thank you for choosing the FunKey S ! The FunKey S is the world's smallest foldable retro-gaming console. Because of its foldable design, the FunKey S provides a surprisingly large screen and comfortable key pads while open, but it stays compatible with a keychain usage when closed.","title":"Welcome to FunKey!"},{"location":"#basic-operation","text":"The FunKey S operation is so straightforward that a 6-year old child should be able to operate it without any user's manual for the most common tasks. But just to make sure you are not missing something, you can find the basic device operation description in the Quickstart section .","title":"Basic operation"},{"location":"#more-advanced-features","text":"Despite its size, the FunKey S is packed with features, and this documentation will also provide more advanced tips in the Tutorials section .","title":"More advanced features"},{"location":"#developers","text":"For developers, a full Developer's Guide is included, with both Hardware and Software subsections.","title":"Developers"},{"location":"#open-source-files","text":"All the software repositories are accessible on our Github . The developer section is a great way to understand its secrets. All the electronic schematics and layouts are accessible here . For mechanical tinkerers or professionals, all the 3D step files are accessible on Grabcad","title":"Open source files"},{"location":"#miscellaenous-stuff","text":"Last but not least, this documentation would not be complete without a Glossary of terms and an FAQ section for reference.","title":"Miscellaenous stuff"},{"location":"developer_guide/hardware_reference/","text":"The FunKey S is the world's smallest foldable retro-gaming console. Holding a world's record is great, but we wanted a device that was actually playable and that still could be attached to a keychain. Reaching this goal required more than just the usual job to shrink everything you can: it required a radical change in the design itself. Foldable Design \u00b6 The idea to use a foldable clamshell design came up rapidly as the only way to get both a small form factor when closed, and offer the largest screen and keypads while playing. But this solution also brings a lot of challenges, as the required hinge make connections between the 2 halfs of the shell more difficult. However, this has been done before in the classic GameBoy Advanced SP, or in many clamshell cellphones from some years ago, so why can't we? Design Goals \u00b6 Passed this first design decision, we fixed ourselves some additional goals in order to provide the user a good gaming experience: have a CPU that is powerful enough to be able to emulate most retro-gaming consoles, up to the PS1 have a good quality screen with a resolution large enough to display even the games featuring small texts have a set of keys and pads large enough and complete enough to be able to play comfortably have a built-in audio capability (who can play without sound?) be able for a 6-year old child to add games and emulators as an extremely nomad device, be able to stop playing just by closing the console, and restart when opening it just where you left (we call this feature \" Instant Play \") Design Constraints \u00b6 Besides the constraint brought by the hinge listed above, the main difficulty is due to the maximum device dimensions that should not exceed those of a (large) car key. And because of the foldable design, the most constrained dimension is thickness: having a folding screen also means doubling the plastic enclosure around the screen and the other internal parts. In order to meet these constraints, we had to take more (heart-breaking) decisions: a CPU with external DRAM chips would take too much real-estate on the PCB , so we had to find a CPU with integrated DRAM an audio Jack would be very difficult to integrate, so we decided to use an internal speaker instead an USB C connector is too thick and large, so we used a Micro USB connector instead a Micro SD connector with external access would be too large, as the required \"push/push\" mechanism, plus the mechanical design to make sure the card does not get loose make the solution much larger because of real-estate constraints on the PCB as well as power consumption constraints, we decided to not integrate Wi-Fi and/or Bluetooth the only keypad technology able to meet our thickness goal is using integrated tactile switches battery capacity had to be adjusted to the maximum available internal volume, using standard battery dimensions","title":"Hardware Reference"},{"location":"developer_guide/hardware_reference/#foldable-design","text":"The idea to use a foldable clamshell design came up rapidly as the only way to get both a small form factor when closed, and offer the largest screen and keypads while playing. But this solution also brings a lot of challenges, as the required hinge make connections between the 2 halfs of the shell more difficult. However, this has been done before in the classic GameBoy Advanced SP, or in many clamshell cellphones from some years ago, so why can't we?","title":"Foldable Design"},{"location":"developer_guide/hardware_reference/#design-goals","text":"Passed this first design decision, we fixed ourselves some additional goals in order to provide the user a good gaming experience: have a CPU that is powerful enough to be able to emulate most retro-gaming consoles, up to the PS1 have a good quality screen with a resolution large enough to display even the games featuring small texts have a set of keys and pads large enough and complete enough to be able to play comfortably have a built-in audio capability (who can play without sound?) be able for a 6-year old child to add games and emulators as an extremely nomad device, be able to stop playing just by closing the console, and restart when opening it just where you left (we call this feature \" Instant Play \")","title":"Design Goals"},{"location":"developer_guide/hardware_reference/#design-constraints","text":"Besides the constraint brought by the hinge listed above, the main difficulty is due to the maximum device dimensions that should not exceed those of a (large) car key. And because of the foldable design, the most constrained dimension is thickness: having a folding screen also means doubling the plastic enclosure around the screen and the other internal parts. In order to meet these constraints, we had to take more (heart-breaking) decisions: a CPU with external DRAM chips would take too much real-estate on the PCB , so we had to find a CPU with integrated DRAM an audio Jack would be very difficult to integrate, so we decided to use an internal speaker instead an USB C connector is too thick and large, so we used a Micro USB connector instead a Micro SD connector with external access would be too large, as the required \"push/push\" mechanism, plus the mechanical design to make sure the card does not get loose make the solution much larger because of real-estate constraints on the PCB as well as power consumption constraints, we decided to not integrate Wi-Fi and/or Bluetooth the only keypad technology able to meet our thickness goal is using integrated tactile switches battery capacity had to be adjusted to the maximum available internal volume, using standard battery dimensions","title":"Design Constraints"},{"location":"developer_guide/hardware_reference/architecture/","text":"Block Diagram \u00b6 Eventually, the design constraints listed in the previous section led to the following electronic diagram, featuring 3 main blocks: 1x main PCB (0.8 mm thickness) with components on both sides, the maximum component height above PCB on both sides is 1.5 mm. Current revision for this board is Revision E 1x 1.54\u201d IPS TFT LCD screen with SPI interface and using a custom flex cable, containing a built-in screen controller chip 1x 420 mAh 402540 LiPo battery, containing an active protection circuitry 3D View \u00b6 A 3D rendering of the PCBA done in KiCAD produces the images below: BOM \u00b6 An interactive BOM is available in the next section . Schematics and Layout \u00b6 All the hardware design and production files required to build the FunKey S retro-gaming console electronic PCBA using the KiCAD ECAD tools are available as Open Hardware in the FunKey S Hardware repository . Topological vs. logical schematic symbols The FunKey S schematics use symbols and placement that are as close as possible to their corresponding physical package and layout, instead of defining symbols that are conveniently arranged by logical properties. Even if this makes schematics more complex at first sight, the benefit of this approach is that the step to go from the schematics to the physical layout becomes much easier, and so is the debugging of the physical board, which is then very close to the schematics too. Explicit schematic wires Another habit that is used everywhere in the FunKey S schematics is that all signals (except power supplies and GND) are routed using explicit wires, rather than counting on invisible connection by net names and relying of the reader to search these names all over the place. This forces related components to be clustered in compact groups to shorten the wires, and put more focus on inter-cluster signals, with a natural inclination to unravel wire nests in the schematics before laying out the actual board. Power supply nets There are some \"PWR_FLAG\" symbols added here and there, which is the proper way in KiCAD to declare that a given net has a known supply and thus prevent the ERC (Electrical Rule Check) to throw an error. The schematics will be discussed function by function in the following sections.","title":"Architecture"},{"location":"developer_guide/hardware_reference/architecture/#block-diagram","text":"Eventually, the design constraints listed in the previous section led to the following electronic diagram, featuring 3 main blocks: 1x main PCB (0.8 mm thickness) with components on both sides, the maximum component height above PCB on both sides is 1.5 mm. Current revision for this board is Revision E 1x 1.54\u201d IPS TFT LCD screen with SPI interface and using a custom flex cable, containing a built-in screen controller chip 1x 420 mAh 402540 LiPo battery, containing an active protection circuitry","title":"Block Diagram"},{"location":"developer_guide/hardware_reference/architecture/#3d-view","text":"A 3D rendering of the PCBA done in KiCAD produces the images below:","title":"3D View"},{"location":"developer_guide/hardware_reference/architecture/#bom","text":"An interactive BOM is available in the next section .","title":"BOM"},{"location":"developer_guide/hardware_reference/architecture/#schematics-and-layout","text":"All the hardware design and production files required to build the FunKey S retro-gaming console electronic PCBA using the KiCAD ECAD tools are available as Open Hardware in the FunKey S Hardware repository . Topological vs. logical schematic symbols The FunKey S schematics use symbols and placement that are as close as possible to their corresponding physical package and layout, instead of defining symbols that are conveniently arranged by logical properties. Even if this makes schematics more complex at first sight, the benefit of this approach is that the step to go from the schematics to the physical layout becomes much easier, and so is the debugging of the physical board, which is then very close to the schematics too. Explicit schematic wires Another habit that is used everywhere in the FunKey S schematics is that all signals (except power supplies and GND) are routed using explicit wires, rather than counting on invisible connection by net names and relying of the reader to search these names all over the place. This forces related components to be clustered in compact groups to shorten the wires, and put more focus on inter-cluster signals, with a natural inclination to unravel wire nests in the schematics before laying out the actual board. Power supply nets There are some \"PWR_FLAG\" symbols added here and there, which is the proper way in KiCAD to declare that a given net has a known supply and thus prevent the ERC (Electrical Rule Check) to throw an error. The schematics will be discussed function by function in the following sections.","title":"Schematics and Layout"},{"location":"developer_guide/hardware_reference/audio/","text":"Playing audio is absolutely part of the gaming experience! So for a retro gaming console like the FunKey S , having a decent audio playback is a requirement, despite its lilliputian size. We discarded the solution of using a piezo-electric buzzer: these can get a loud sound in a small volume, but only at their resonance frequency, so the sound quality is extremely poor. Turning back to the solutions used in modern smartphones as an example, there are 2 paths to consider: playing audio internally by the mean of speaker(s) playing audio externally by using headphones, with or without a cord The speakers used in today's smartphones are rather sophisticated and achieve very good performance. However, these are using made-to-measure speakers and cavities, such that they cannot be found and reused as standard parts in a design like ours. As for the external audio solution, the FunKey S is so small that it is not possible to integrate an audio jack on the PCB to connect headphones! And despite our search, there is no simple and small enough way to integrate Bluetooth to output audio to cordless headphones either. The best solution we have found consists in using a single tiny CUI CDM-10008 speaker, that is able to output 72 dB spl @ 1m from a 0.3W input power, with relatively modest dimensions: 10 mm diameter and only a 2.9 mm thickness, out of which 1.4 mm can be inserted into a PCB hole, thus only having a height above PCB of only 1.5 mm. Connections are not easy though, since this speaker is meant to have wires soldered to its pads, but we used 2x castellated (half-round plated holes) pads with a placement just over the speaker pads that enables manual soldering between the speaker and the PCB with a solder blob. Schematic \u00b6 The audio schematic is simple, as the Allwinner V3s already contains an analog stereo audio codec (coder/decoder): we only have to take one of its headphone output channel (left or right) and feed it to a mono audio amplifier. We chose the Diodes Inc. PAM8301 chip because of its cheap price, good availability, its more than sufficient output power of 1.5W and its filterless operation, meaning that no bulky series capacitor is required to drive the speaker. Here is the corresponding schematic: We chose the right headphone channel HPOUTR that is fed to the audio amplifier U2 through a coupling capacitor C3 . The audio amplifier / SD shutdown input is driven by one V3s GPIO (PF7 on pin 100), with a pull-down resistor R2 to disable the amplifier by default. The audio amplifier power supply is filtered using a ferrite bead L1 in order to eliminate high-frequency digital noise, and decoupled by 2 capacitors C4 and C5 , as recommended in the device datasheet. The speaker SP1 is driven in differential mode in order to get the maximum voltage swing and thus the maximum power available for a given output current. Two ESD protection TVS diodes D13 and D14 are added, since the speaker may be accessible to the user through the enclosure grid in front of the speaker.","title":"Audio"},{"location":"developer_guide/hardware_reference/audio/#schematic","text":"The audio schematic is simple, as the Allwinner V3s already contains an analog stereo audio codec (coder/decoder): we only have to take one of its headphone output channel (left or right) and feed it to a mono audio amplifier. We chose the Diodes Inc. PAM8301 chip because of its cheap price, good availability, its more than sufficient output power of 1.5W and its filterless operation, meaning that no bulky series capacitor is required to drive the speaker. Here is the corresponding schematic: We chose the right headphone channel HPOUTR that is fed to the audio amplifier U2 through a coupling capacitor C3 . The audio amplifier / SD shutdown input is driven by one V3s GPIO (PF7 on pin 100), with a pull-down resistor R2 to disable the amplifier by default. The audio amplifier power supply is filtered using a ferrite bead L1 in order to eliminate high-frequency digital noise, and decoupled by 2 capacitors C4 and C5 , as recommended in the device datasheet. The speaker SP1 is driven in differential mode in order to get the maximum voltage swing and thus the maximum power available for a given output current. Two ESD protection TVS diodes D13 and D14 are added, since the speaker may be accessible to the user through the enclosure grid in front of the speaker.","title":"Schematic"},{"location":"developer_guide/hardware_reference/buttons/","text":"As a generic game console emulating many classic ones, the FunKey requires numerous buttons: A soft \"ON/OFF\" button A \" + \" control pad with \"Up\", \"Down\", \"Left\" and \"Right\" buttons A \" X \" control pad with \"A\", \"B\", \"X\" and \"Y\" buttons \"Start\" and a \"Fn\" buttons At least L1 and R1 shoulder buttons As can be seen in the page on the PMIC , the soft \"ON/OFF\" button is directly connected to the power management chip, so we are left with 4 + 4 + 2 = 12 buttons for game control. After testing tactile domes in our FunKey Zero prototype, we decided to go back to integrated tactile switches, as their placement is much easier using a regular SMT pick & place machine like any other components on the PCB , whereas the separate tactile domes required an adhesive tape to be place manually with less accuracy. The Mitsumi BYS-055A1x12 is the same footprint (2.5mm x 1.6mm x 0.55mm) as the more expensive Panasonic EVBBBxAAB00 tactile switches, with a 1.2N actuating force for the \" + \" and \" X \" pads, and a 1.6N actuating force for the \"Start\", \"Fn\" and \"ON/OFF\" buttons. We found these actuating force the best match to provide a good feedback to the user. For the rear left and right shoulder buttons, we exeperimented several models between PCBA rev. C, D and E, until we eventually decided for a replacement for the expensive Panasonic EVP-AEBB2A-1 : This one as an actuating force of 1.6N. GPIO Requirements \u00b6 The Allwinner v3s CPU comes in a large 128-pin TQFP package, with a lot of exposed (51!) GPIO pins: PB0 to PB9 (10) PC0 to PC3 (4) PE0 to PE24 (25) PF0 to PF5 (6) PG0 to PG5 (6) The FunKey specializes some of them for specific interfaces like SDCard, PWM , SPI and I2C buses, console UART , but most of them are left available for I/Os. GPIO Expander \u00b6 But for the FunKey S device and given the small PCB size, wiring all the buttons directly to the V3s puts a lot of constraints on the PCB routing, at such a point that we decided to use a dedicated I2C GPIO expander chip to relieve the burden from the main V3s CPU . We use a common chip for this purpose, that is well supported in the Linux kernel: the NXP PCAL6416AHF.128 . It is marketed as a \"low-voltage translating 16-bit I2C -bus/SMBus I/O expander with interrupt output, reset, and configuration registers\" that just matches exactly our needs. As a bonus, this chip features software-controlable internal pull-up/pull-down resistors, so we don't need to add external ones to fix the defaut button states. The connection with the V3s CPU is achieved using standard I2C clock (SCL) and data (SDA) signals, plus an additional IRQ signal driven by the I/O expander when pre-programmed conditions are met, such as a key press / release event. A RESET signal is used to initialize the chip when required. Schematics \u00b6 Here is the corresponding main schematic for the buttons: The main component is of course the I/O expander U1 , with the control signals to the CPU / PMIC on the north side. The chip's /INT signal is pulled up to the +3V3 power supply by the resistor R1 , such that the active-low interrupt signal is disabled by default. The I/O expander chip features 2 separate power supplies VDD and VDDP for the core and peripheral respectively, each decoupled by a bulk capacitor C1 and C2 . Except for the GPIO I/Os, the only remaining pin is the ADDR pin 18 which provides the I2C address LSB bit, so that you can address 2 PCAL6416AHF.128 chips on the same I2C bus by wiring this pin differently. Tip One oddity is that the pin 6 (P0_5) is connected to the /RESET signal: it is a routing trick to get this signal to go through this pin pad, as it was very difficult to access it otherwise... The \"Start\" and \"Select\" buttons S1 and S2 are 2 low-profile SMT tactile switches, each featuring an ESD protection TVS diode D8 and D5 , as these buttons are of course accessible by the user! The other buttons are wired in the same fashion: The \"U\", \"L\", \"D\", \"R\", \"A\", \"B\", \"X\" and \"Y\" buttons S3 , S4 , S5 , S6 , S8 , S9 , S10 and S11 are of the same kind and also have a respective TVS diodes D2 , D3 , D4 , D5 , D6 , D7 , D8 , D9 , D10 and D11 . The left ( S12 ) and right ( S7 ) shoulder buttons are right angle SMT tactile buttons, with their TVS diode D1 and D12 . Benefit \u00b6 The main advantage of this solutions is that the 12 signals to wire the buttons to the CPU are replaced by only 4 signals, from which 3 are shared with the other I2C peripherals (the PMIC ) on the bus. It is then much easier to route this dense PCB by delegating the button GPIO handling to a satellite chip.","title":"Buttons"},{"location":"developer_guide/hardware_reference/buttons/#gpio-requirements","text":"The Allwinner v3s CPU comes in a large 128-pin TQFP package, with a lot of exposed (51!) GPIO pins: PB0 to PB9 (10) PC0 to PC3 (4) PE0 to PE24 (25) PF0 to PF5 (6) PG0 to PG5 (6) The FunKey specializes some of them for specific interfaces like SDCard, PWM , SPI and I2C buses, console UART , but most of them are left available for I/Os.","title":"GPIO Requirements"},{"location":"developer_guide/hardware_reference/buttons/#gpio-expander","text":"But for the FunKey S device and given the small PCB size, wiring all the buttons directly to the V3s puts a lot of constraints on the PCB routing, at such a point that we decided to use a dedicated I2C GPIO expander chip to relieve the burden from the main V3s CPU . We use a common chip for this purpose, that is well supported in the Linux kernel: the NXP PCAL6416AHF.128 . It is marketed as a \"low-voltage translating 16-bit I2C -bus/SMBus I/O expander with interrupt output, reset, and configuration registers\" that just matches exactly our needs. As a bonus, this chip features software-controlable internal pull-up/pull-down resistors, so we don't need to add external ones to fix the defaut button states. The connection with the V3s CPU is achieved using standard I2C clock (SCL) and data (SDA) signals, plus an additional IRQ signal driven by the I/O expander when pre-programmed conditions are met, such as a key press / release event. A RESET signal is used to initialize the chip when required.","title":"GPIO Expander"},{"location":"developer_guide/hardware_reference/buttons/#schematics","text":"Here is the corresponding main schematic for the buttons: The main component is of course the I/O expander U1 , with the control signals to the CPU / PMIC on the north side. The chip's /INT signal is pulled up to the +3V3 power supply by the resistor R1 , such that the active-low interrupt signal is disabled by default. The I/O expander chip features 2 separate power supplies VDD and VDDP for the core and peripheral respectively, each decoupled by a bulk capacitor C1 and C2 . Except for the GPIO I/Os, the only remaining pin is the ADDR pin 18 which provides the I2C address LSB bit, so that you can address 2 PCAL6416AHF.128 chips on the same I2C bus by wiring this pin differently. Tip One oddity is that the pin 6 (P0_5) is connected to the /RESET signal: it is a routing trick to get this signal to go through this pin pad, as it was very difficult to access it otherwise... The \"Start\" and \"Select\" buttons S1 and S2 are 2 low-profile SMT tactile switches, each featuring an ESD protection TVS diode D8 and D5 , as these buttons are of course accessible by the user! The other buttons are wired in the same fashion: The \"U\", \"L\", \"D\", \"R\", \"A\", \"B\", \"X\" and \"Y\" buttons S3 , S4 , S5 , S6 , S8 , S9 , S10 and S11 are of the same kind and also have a respective TVS diodes D2 , D3 , D4 , D5 , D6 , D7 , D8 , D9 , D10 and D11 . The left ( S12 ) and right ( S7 ) shoulder buttons are right angle SMT tactile buttons, with their TVS diode D1 and D12 .","title":"Schematics"},{"location":"developer_guide/hardware_reference/buttons/#benefit","text":"The main advantage of this solutions is that the 12 signals to wire the buttons to the CPU are replaced by only 4 signals, from which 3 are shared with the other I2C peripherals (the PMIC ) on the bus. It is then much easier to route this dense PCB by delegating the button GPIO handling to a satellite chip.","title":"Benefit"},{"location":"developer_guide/hardware_reference/cpu/","text":"The main part in the FunKey S device is of course its CPU . As discussed in the Design Constraints section , a CPU with external DRAM chips would take too much real-estate on the PCB , so we had to find a CPU with integrated DRAM . There are several options for integrating RAM in a SoC : use SRAM : not possible because of the small amount of memory available (64Mbit max.) embedded DRAM on the same chip: This is the solution used in the Apple M1 chip , but this chip is not available for retail and no other solutions seems readily available Stacked Chip-on-Chip ( PoP ): This is the solution used on some Raspberry Pi boards, but this solution is only available for custom designs, with minimum order quantities not compatible with the FunKey S low volumes DRAM die in SiP : with capacities ranging from 64Mbit to 1Gbit We found only 2 manufacturers providing the last option: Microchip and Allwinner Technology . Microchip solutions are too limited in term of CPU power for our needs (ARM926EJ-S or Cortex A5), so we did not consider them. And with the exception of the mostly similar Allwinner S3 CPU which features the same characteristics but with 128MB DDR3 DRAM in an FBGA234 package, the Allwinner V3s is the CPU with integrated DRAM having the highest memory capacity (512Mbit / 64MB DDR2 DRAM ): Despite its larger package size (16mm x 16mm vs. 11mm x 11mm), we selected the V3s over the S3 because of its better availability and ease of soldering of the LQFP128 over the FBGA234 package for the prototypes. The V3s features a rather powerful single-core ARM Cortex A7-A clocked @ 1.2GHz with an additional Vector Floating Point Version 4 (vfpv4) FPU extension and an SIMD NEON architecture with a 32 \u00d7 64-bit register file and 64-bit ALU, but unfortunately no GPU or 2D graphic engine containing a hardware scaler that could be extremely useful for the retro-gaming emulators. As a bonus, as the V3s is based on an ARM Cortex A7-A low-power architecture, it also features a low power consumption which is required by our battery operation. These characteristics do not look very impressive compared to a Raspberry Pi for example, but using many optimizations and after running many tests, we found them nevertheless satisfactory for our purpose. CPU Schematics \u00b6 Here is the part of the schematics corresponding to the CPU core: SoC Blocks \u00b6 As can be seen, there is not much besides the CPU chip U3 itself... The CPU is in fact a SoC (System on Chip) containing a collection of built-in peripheral and memory blocks along with the CPU itself: the LCD / DSi display peripheral the GPIO port G / SDC1 ( SD Card #1 ) interface the AUDIO codec the LRADC0 (Low-Resolution Analog to Digital Converter) the USB OTG controller the GPIO port F / SDC0 ( SD Card #0) / UART0 interface the RTC (Real Time Clock) timer the EPHY (Ethernet PHYsical) interface the MIPI CSi camera interface the built-in 64 MB DDR2 DRAM the GPIO port C / SPI interface the GPIO port B / UART2 / PWM0 / PWM1 / TWI0 ( I2C #0) / TWI1 ( I2C #1 ) Among these, the FunKey device only uses a few blocks: AUDIO USB (as device only) SDC0 (for SD Card) RTC DRAM SPI (for the LCD screen) PWM0 (for backlight) TWI0 (for I2C bus to control the GPIO expander and power management chips) A couple of GPIOs to power the audio power amplifier and get feedback interrupt signals from the the GPIO expander and power management chips CPU Power Supplies \u00b6 What is remarkable though is that the V3s requires a lot of different voltages for its power supply: +3V3 for the I/O power supply +3V3_AO for the Always-On power supply ( RTC timer) +3V0 for analog power supply +1V8 for the DDR2 DRAM power supply +1V25 for the core power supply This profusion of different power supplies as well as the high power drawn by some of them (1.2A for +3V3, 1.6A for +1.25V) requires a sophisticated power management that will be detailed further. LRADC0 \u00b6 The LRADC0 (Low-Resolution Analog to Digital Converter #0) is designed to measure the voltage of a resistor ladder switched by keyboard keys: this single input is thus in theory able to manage a keyboard of up to 10 keys @ 250 Hz. Unfortunately, the FunKey has 12 keys (U/D/L/R, A/B/X/Y, RR/RL, Start and Fn), and the resulting key detection accuracy is not compatible with a gaming usage because of long term stability problems. This is the reason why it is not used in the FunKey and just terminated by a proper low-pass filter R6 / C9 to avoid picking up noise glitches. SD Card \u00b6 The SD Card interface is almost a direct connection between the chip and the dedicated SD Card connector. Only a single series resistor R8 is required on the high-speed clock line in order to prevent ringing . Crystals \u00b6 The V3s chips requires 2 crystals: one low-frequency 32.768 kHz crystal Y1 for the RTC clock one high-frequency 24 MHz crystal Y2 for deriving the 1.2 GHz clock The 24 MHz crystal is used by an internal oscillator to lock the phase of the 1.2 GHz oscillator using a PLL (Phase-Locked Loop). The 32.768 kHz crystal is used by another internal oscillator to tick the RTC (Real-Time Clock) at a standard watch frequency. These crystals require 2 load capacitors each ( C12 / C13 and C14 / C15 respectively) in order to guarantee that the oscillators still start and work with a comfortable operation margin taking into account voltage, temperature and aging. The 32.768 kHz crystal features an additional high-value resistor R12 in order to limit the internal oscillator's output current and thus reduce further the RTC timer power consumption. For more details on crystal oscillator design, please check this application note from STM . DRAM \u00b6 The DRAM within the V3s chip is a DDR2 one , meaning that its data lines are clocked using both edges of an up to 400 MHz clock signal. At these high frequencies, even short wires have a length that is of the same order of magnitude as the signal's wavelength and thus each signal should be considered as a transmission line , for which impedance must be matched to avoid signal reflections, requiring termination resistors on the data lines DQx. DDR2 or DDR3 DRAMs feature merged drivers and dynamic on-chip termination like this (\"VDDQ/2\" is labeled \"SVREF\" in our schematic): The V3s DDR2 DRAM has an active termination calibration circuitry and procedure called \" ZQ Calibration \" requiring an accurate 1% 240 \u2126 resistor R11 connected internally like this: More information on the DDR2 DRAM ZQ Calibration subject can be found in this Micron Application Note .","title":"CPU"},{"location":"developer_guide/hardware_reference/cpu/#cpu-schematics","text":"Here is the part of the schematics corresponding to the CPU core:","title":"CPU Schematics"},{"location":"developer_guide/hardware_reference/cpu/#soc-blocks","text":"As can be seen, there is not much besides the CPU chip U3 itself... The CPU is in fact a SoC (System on Chip) containing a collection of built-in peripheral and memory blocks along with the CPU itself: the LCD / DSi display peripheral the GPIO port G / SDC1 ( SD Card #1 ) interface the AUDIO codec the LRADC0 (Low-Resolution Analog to Digital Converter) the USB OTG controller the GPIO port F / SDC0 ( SD Card #0) / UART0 interface the RTC (Real Time Clock) timer the EPHY (Ethernet PHYsical) interface the MIPI CSi camera interface the built-in 64 MB DDR2 DRAM the GPIO port C / SPI interface the GPIO port B / UART2 / PWM0 / PWM1 / TWI0 ( I2C #0) / TWI1 ( I2C #1 ) Among these, the FunKey device only uses a few blocks: AUDIO USB (as device only) SDC0 (for SD Card) RTC DRAM SPI (for the LCD screen) PWM0 (for backlight) TWI0 (for I2C bus to control the GPIO expander and power management chips) A couple of GPIOs to power the audio power amplifier and get feedback interrupt signals from the the GPIO expander and power management chips","title":"SoC Blocks"},{"location":"developer_guide/hardware_reference/cpu/#cpu-power-supplies","text":"What is remarkable though is that the V3s requires a lot of different voltages for its power supply: +3V3 for the I/O power supply +3V3_AO for the Always-On power supply ( RTC timer) +3V0 for analog power supply +1V8 for the DDR2 DRAM power supply +1V25 for the core power supply This profusion of different power supplies as well as the high power drawn by some of them (1.2A for +3V3, 1.6A for +1.25V) requires a sophisticated power management that will be detailed further.","title":"CPU Power Supplies"},{"location":"developer_guide/hardware_reference/cpu/#lradc0","text":"The LRADC0 (Low-Resolution Analog to Digital Converter #0) is designed to measure the voltage of a resistor ladder switched by keyboard keys: this single input is thus in theory able to manage a keyboard of up to 10 keys @ 250 Hz. Unfortunately, the FunKey has 12 keys (U/D/L/R, A/B/X/Y, RR/RL, Start and Fn), and the resulting key detection accuracy is not compatible with a gaming usage because of long term stability problems. This is the reason why it is not used in the FunKey and just terminated by a proper low-pass filter R6 / C9 to avoid picking up noise glitches.","title":"LRADC0"},{"location":"developer_guide/hardware_reference/cpu/#sd-card","text":"The SD Card interface is almost a direct connection between the chip and the dedicated SD Card connector. Only a single series resistor R8 is required on the high-speed clock line in order to prevent ringing .","title":"SD Card"},{"location":"developer_guide/hardware_reference/cpu/#crystals","text":"The V3s chips requires 2 crystals: one low-frequency 32.768 kHz crystal Y1 for the RTC clock one high-frequency 24 MHz crystal Y2 for deriving the 1.2 GHz clock The 24 MHz crystal is used by an internal oscillator to lock the phase of the 1.2 GHz oscillator using a PLL (Phase-Locked Loop). The 32.768 kHz crystal is used by another internal oscillator to tick the RTC (Real-Time Clock) at a standard watch frequency. These crystals require 2 load capacitors each ( C12 / C13 and C14 / C15 respectively) in order to guarantee that the oscillators still start and work with a comfortable operation margin taking into account voltage, temperature and aging. The 32.768 kHz crystal features an additional high-value resistor R12 in order to limit the internal oscillator's output current and thus reduce further the RTC timer power consumption. For more details on crystal oscillator design, please check this application note from STM .","title":"Crystals"},{"location":"developer_guide/hardware_reference/cpu/#dram","text":"The DRAM within the V3s chip is a DDR2 one , meaning that its data lines are clocked using both edges of an up to 400 MHz clock signal. At these high frequencies, even short wires have a length that is of the same order of magnitude as the signal's wavelength and thus each signal should be considered as a transmission line , for which impedance must be matched to avoid signal reflections, requiring termination resistors on the data lines DQx. DDR2 or DDR3 DRAMs feature merged drivers and dynamic on-chip termination like this (\"VDDQ/2\" is labeled \"SVREF\" in our schematic): The V3s DDR2 DRAM has an active termination calibration circuitry and procedure called \" ZQ Calibration \" requiring an accurate 1% 240 \u2126 resistor R11 connected internally like this: More information on the DDR2 DRAM ZQ Calibration subject can be found in this Micron Application Note .","title":"DRAM"},{"location":"developer_guide/hardware_reference/magnetic_switch/","text":"The FunKey S features no ON/OFF switch. Instead, a small magnet placed near the LCD screen in the lid is detected using a magnetic sensor that is placed in front of it when the lid is closed. The magnetic sensor controls the PMIC N_OE (Negative logic Output Enable) input, which turns off all voltage rails except the +3.3V Always On when the signal is at the high level. We thus need a sensor that will close when a magnetic field is detected, and in order to reduce power consumption when the FunKey S is turned off and preserve its battery when stored on a shelf, it should be a fully passive device. This rules out magnetic Hall effect sensors, wich require some power for their operation. The only practical solution is to use a \"Reed switch\", which is a relatively thin flexible piece of metal inside the switch envelope that is sensitive to a magnetic field, which opens or closes a contact accordingly. Most of the Reed switch available are made of a tiny glass tube, which is rather fragile and may break if the device falls on the floor, something quite usual for a keychain... We found only a unique plastic-molded model which almost meets our low-profile requirements of 1.5 mm (1.6 mm height!): the Standex Meder MK24 . Here is the corresponding schematics, already covered in the PMIC discussion: The global PMIC chip enable signal N_OE is activated by default through a 47k\u2126 resistor R17 to GND, but the magnetic Reed switch S14 can disable it by forcing its level to +VOUT, with a filter capacitor C83 .","title":"Magnetic Switch"},{"location":"developer_guide/hardware_reference/screen/","text":"The second most important part in the FunKey S is certainly its screen: in an overall form factor of roughly 45mm x 45mm x 15mm (1.75\" x 1.75\" x 0.6\"), it has to be comfortable enough to provide a good gaming experience. In theory, 1.75\" would allows to shoehorn a 2.4\" (diagonal) square screen, but in practice, 2.4\" screens are seldom square and more rectangular in shape. Unless you are a large manufacturer and selling millions of devices, you are limited to using the existing screen sizes that are available on the market, which most of the time were designed for a long-forgotten specific devices (think of PDAs, MP3 players, clam-shell phones, pods, etc.) and standard aspect ratio are either 1:1, 5:3 or 16:9. Thus, for a given pixel technology, this results in rather standard screen sizes. So the next available size down are 2\" and 1.8\", but these screens tend to be quite thick and based on an older technology, so their typical resolution is rather limited @ 128x160 pixels: too small for gamers. Still going down in size, you can find 1.5\" to 1.55\" screens with an interesting resolution of 240x240 or even 320 x 320 (\"Retina\") pixels, but most of them use a fast MIPI DSi interface. These particular screens were popular as they were used in the 6 th -generation \"square\" iPods, but unfortunately, they require a dedicated controller on the host side, which is only available in higher-end SoC . Another important characteristic of the required screen is that it needs to have a narrow flex cable in order to be rolled into the hinge (like a fly-paper ) in order to spread the mechanical flex constraint over several loop rather than at always the same section, resulting in less wear and an expected longer lifespan. Fortunately, we found this 1.54\" LCD screen on AliBaba: What makes this screen special is its standard SPI interface, which only requires a few wires and thus a narrow flex cable like the MIPI DSi interface, so it is easy to roll into a hinge. But unlike the MIPI DSi one, the SPI interface is readily available on most of the SoC , including the Allwinner V3s. This 1.54\" display features a 240x240 16/18-bit full color pixel resolution and is an IPS display, so the color looks great up to 80 degrees off-axis in any direction. However, in order to achieve a 50 fps @ 240 x 240 pixel resolution in RGB565 (2 bytes / pixel), this requires a ~44 MHz SPI clock rate, which is rather high. Once again, we were fortunate as both the V3s CPU and the screen built-in controller (a Sitronix ST7789V ) both support this high clock speed (after checking with the manufacturer and despite the controller datasheet that specifies only a serial clock cycle (Write) of 66 ns or 15 MHz!). We were even luckier as its backlight consists in 3 white LEDs in parallel and not in series, such that no additional step-up DC-DC converter is required, as a standard 3.3V / 60 mA (typical) power supply is sufficient. Of course, we won't be able to drive this current directly from a CPU GPIO and the backlight will require an additional transistor to interface to the LCD backlight. Its flex cable requires a mating Hirose 0.4 mm pitch DF37NB-24DS-0.4V dual row SMT connector, out of which only one single row is actually used. Customization \u00b6 Unfortunately, the flex cable for the stock LCD screen we found does not match our particular FunKey S mechanical design. For the prototypes, we designed custom flex extension cables for a ~ $100 cost, but we had to design our own custom flex and have this standard screen assembly attached to it for mass production, with a one-time tooling fee of ~ $800. Schematic \u00b6 The schematic is quite simple: The main component is of course the Hirose screen connector J3 , with the following signals: LEDA: the backlight LED common Anode connection (+) GND +3V3 power supply /SPI_CS: SPI Chip Select SPI_MOSI: SPI Master Out / Slave In SPI_CLK: SPI Clock TE: Tearing Effect sync signal from the screen RS: LCD -specific Register/Memory Select (or Data/Control Select) LCD_RESET: LCD Reset All data signals feature an ESD TVS protection diode D19-D24 and D37 , and except for the power supplies and LEDA + LCD_RESET and TE signals, all signals are directly connected to the V3s CPU 's SPI interface, so there is not much to say about these. The LCD_RESET signal is controlled by a V3s GPIO (PB2 on pin 41). The TE signal from the screen controller is fed to an interrupt-enabled input pin PB1 (pin 40) in order to synchronize the sending of data to the screen with its inactive period in order to avoid the hardware tearing effect. Backlight PWM \u00b6 The backlight control requires a few more components: a MOSFET-P transistor Q1 and 2 resistors R5 and R7 to provide its polarization, more on this below. As the backlight LEDs cathode (-) pin are directly tied to GND within the screen, we need to drive these LEDs \"from the high-side\", i.e. between the +3V3 power supply and the LEDA pin, so a MOSFET-P transistor is necessary: As we want the backlight to be on by default, we need to drive it to GND by default: this is the role of R7 . The role of R5 is then to make sure that -Vgs is driven below its threshold voltage and turns off the transistor when the CPU drives a GPIO high. As an ultimate sophistication, we can drive the backlight from the CPU using one of its built-in PWM controllers PWM0 with a varying duty-cycle, thus controlling the LCD backlight brightness accurately. For this purpose, the other end of the R5 resistor is connected to the PB4 output (pin 43) on the V3s, wich provides this function.","title":"Screen"},{"location":"developer_guide/hardware_reference/screen/#customization","text":"Unfortunately, the flex cable for the stock LCD screen we found does not match our particular FunKey S mechanical design. For the prototypes, we designed custom flex extension cables for a ~ $100 cost, but we had to design our own custom flex and have this standard screen assembly attached to it for mass production, with a one-time tooling fee of ~ $800.","title":"Customization"},{"location":"developer_guide/hardware_reference/screen/#schematic","text":"The schematic is quite simple: The main component is of course the Hirose screen connector J3 , with the following signals: LEDA: the backlight LED common Anode connection (+) GND +3V3 power supply /SPI_CS: SPI Chip Select SPI_MOSI: SPI Master Out / Slave In SPI_CLK: SPI Clock TE: Tearing Effect sync signal from the screen RS: LCD -specific Register/Memory Select (or Data/Control Select) LCD_RESET: LCD Reset All data signals feature an ESD TVS protection diode D19-D24 and D37 , and except for the power supplies and LEDA + LCD_RESET and TE signals, all signals are directly connected to the V3s CPU 's SPI interface, so there is not much to say about these. The LCD_RESET signal is controlled by a V3s GPIO (PB2 on pin 41). The TE signal from the screen controller is fed to an interrupt-enabled input pin PB1 (pin 40) in order to synchronize the sending of data to the screen with its inactive period in order to avoid the hardware tearing effect.","title":"Schematic"},{"location":"developer_guide/hardware_reference/screen/#backlight-pwm","text":"The backlight control requires a few more components: a MOSFET-P transistor Q1 and 2 resistors R5 and R7 to provide its polarization, more on this below. As the backlight LEDs cathode (-) pin are directly tied to GND within the screen, we need to drive these LEDs \"from the high-side\", i.e. between the +3V3 power supply and the LEDA pin, so a MOSFET-P transistor is necessary: As we want the backlight to be on by default, we need to drive it to GND by default: this is the role of R7 . The role of R5 is then to make sure that -Vgs is driven below its threshold voltage and turns off the transistor when the CPU drives a GPIO high. As an ultimate sophistication, we can drive the backlight from the CPU using one of its built-in PWM controllers PWM0 with a varying duty-cycle, thus controlling the LCD backlight brightness accurately. For this purpose, the other end of the R5 resistor is connected to the PB4 output (pin 43) on the V3s, wich provides this function.","title":"Backlight PWM"},{"location":"developer_guide/hardware_reference/sd-card/","text":"The FunKey S game console uses the SD Card both as its boot device and its only storage device, so a good operation of this interface is absolutely mandatory. The Allwinner V3s provides 2x 4-bit MMC / SD Card / SDIO interfaces. In the FunKey, only interface #0 is used. If you look on the Web, you will find many contradictory SD Card interface designs, with a combination of pull-up / pull-down resistors, ESD devices and power supply filtering, with all pins wired or not, such that it is very difficult to know what is really required. To better understand the situation, we need to go back to the specifications. Specifications \u00b6 The SD Card physical interface is provided in the \" SD specifications, part 1, Physical Layer Specification version 2.00, May 9, 2006 \", for which a simplified version is available here . The MMC phyiscal interface can be found in the \" Multi Media Card System Specification version 4.3, JESD84-A43, November 2007 \", available here (registration required). But a good summary of the requirements is given in the \" AN10911 SD (HC)-memory card and MMC Interface conditioning \" application note from NXP, from which this schematic is taken: Warning This schematic does not include details concerning card-supply and typical power-supply decoupling capacitors. Write Protect (WP) \u00b6 A mechanical write protect switch is provided in the full-size SD Card, but not in the mini or micro SD Card form factor. As we plan to use a micro SD Card only, it is not used for the FunKey, along with its pull-up resistor and ESD protection. Card Detection (CD) \u00b6 As the SD Card is mandatory to boot the FunKey S , is always inserted and opening the device is required for its removal, we don't need the optional card detect mechanical switch feature (even if the chosen connector provides it) and its related pull-up resistor and ESD protection. The SD Card specification provides another mean to detect the card using a card built-in pull-up resistor on its DAT3 signal, that can be later disconnected during normal operation using he SET_CLR_CARD_DETECT ( ACMD42 ) command. In order to correctly detect if the card is inserted, a high value external pull-down resistor (> 270 k\u2126) is required to drive the detect signal low when no card is inserted, while the card built-in 10-50 k\u2126 resistor will drive this signal high when inserted. However, this feature is not compatible with MMC cards, so its usage should be avoided and the mechanical detection is preferred. Pull-Up Resistors \u00b6 Both the SD Card and MMC specifications require not to leave the interface signals floating, except for the CLK signal, where a pull resistor would cause significant signal distortion because of the required high speed and short rise/fall times. However, it is recommended to add a series resistor on this CLK signal as close as possible to the clock source (the CPU ) to avoid ringing, as we already discussed it in the page about the CPU . Fortunately, the Allwinner V3s CPU provides internal pull-up resistors for all these signals, so we don't have to add external pull-up resistors. These resistors are given with a typical value of 100 k\u2126 (50 min, 150 max). Unfortunately, the CMD signal for MMC card features an open-drain output mode, and its value should be undercut (down to 4.7 k\u2126) to guarantee a sufficiently short rise time in this mode. Schematics \u00b6 The FunKey SD Card interface schematic is the following: As can be expected, the main component is the Micro SD (TF Card) Push/Pull connector J4 , which has been selected for its low-profile (1.3 mm height) characteristic and overall minimal dimensions. Tip \"Push-Pull\" means that you have to \"Push\" to insert the card and to \"Pull\" to remove it, i.e. the operation is completely manual, whereas \"Push/Push\" implies that you have a bistable mechanism to remove the card. Even if in the FunKey device the SD Card and its connector are not accessible without opening the enclosure, there may be some situations where the user may decide to do so. We thus attach an ESD protection TVS diode ( D16 , D17 , D18 , D25 , D26 , D27 , D28 ) on each signal to avoid any ESD hazard. As discussed above, a single pull-up resistor R10 is used on the CMD signal for MMC compatibility. The micro SD Card connector built-in card detection switch is not used, since the card must always be inserted for the FunKey S to boot, and the corresponding pins are thus connected to GND. The SD Card power supply is applied through an RC low-pass filter R9 / C11 in order to provide a soft-start operation, as the card built-in large bulk capacitor on its power rail may collapse the supply voltage when initially powered up.","title":"SD Card"},{"location":"developer_guide/hardware_reference/sd-card/#specifications","text":"The SD Card physical interface is provided in the \" SD specifications, part 1, Physical Layer Specification version 2.00, May 9, 2006 \", for which a simplified version is available here . The MMC phyiscal interface can be found in the \" Multi Media Card System Specification version 4.3, JESD84-A43, November 2007 \", available here (registration required). But a good summary of the requirements is given in the \" AN10911 SD (HC)-memory card and MMC Interface conditioning \" application note from NXP, from which this schematic is taken: Warning This schematic does not include details concerning card-supply and typical power-supply decoupling capacitors.","title":"Specifications"},{"location":"developer_guide/hardware_reference/sd-card/#write-protect-wp","text":"A mechanical write protect switch is provided in the full-size SD Card, but not in the mini or micro SD Card form factor. As we plan to use a micro SD Card only, it is not used for the FunKey, along with its pull-up resistor and ESD protection.","title":"Write Protect (WP)"},{"location":"developer_guide/hardware_reference/sd-card/#card-detection-cd","text":"As the SD Card is mandatory to boot the FunKey S , is always inserted and opening the device is required for its removal, we don't need the optional card detect mechanical switch feature (even if the chosen connector provides it) and its related pull-up resistor and ESD protection. The SD Card specification provides another mean to detect the card using a card built-in pull-up resistor on its DAT3 signal, that can be later disconnected during normal operation using he SET_CLR_CARD_DETECT ( ACMD42 ) command. In order to correctly detect if the card is inserted, a high value external pull-down resistor (> 270 k\u2126) is required to drive the detect signal low when no card is inserted, while the card built-in 10-50 k\u2126 resistor will drive this signal high when inserted. However, this feature is not compatible with MMC cards, so its usage should be avoided and the mechanical detection is preferred.","title":"Card Detection (CD)"},{"location":"developer_guide/hardware_reference/sd-card/#pull-up-resistors","text":"Both the SD Card and MMC specifications require not to leave the interface signals floating, except for the CLK signal, where a pull resistor would cause significant signal distortion because of the required high speed and short rise/fall times. However, it is recommended to add a series resistor on this CLK signal as close as possible to the clock source (the CPU ) to avoid ringing, as we already discussed it in the page about the CPU . Fortunately, the Allwinner V3s CPU provides internal pull-up resistors for all these signals, so we don't have to add external pull-up resistors. These resistors are given with a typical value of 100 k\u2126 (50 min, 150 max). Unfortunately, the CMD signal for MMC card features an open-drain output mode, and its value should be undercut (down to 4.7 k\u2126) to guarantee a sufficiently short rise time in this mode.","title":"Pull-Up Resistors"},{"location":"developer_guide/hardware_reference/sd-card/#schematics","text":"The FunKey SD Card interface schematic is the following: As can be expected, the main component is the Micro SD (TF Card) Push/Pull connector J4 , which has been selected for its low-profile (1.3 mm height) characteristic and overall minimal dimensions. Tip \"Push-Pull\" means that you have to \"Push\" to insert the card and to \"Pull\" to remove it, i.e. the operation is completely manual, whereas \"Push/Push\" implies that you have a bistable mechanism to remove the card. Even if in the FunKey device the SD Card and its connector are not accessible without opening the enclosure, there may be some situations where the user may decide to do so. We thus attach an ESD protection TVS diode ( D16 , D17 , D18 , D25 , D26 , D27 , D28 ) on each signal to avoid any ESD hazard. As discussed above, a single pull-up resistor R10 is used on the CMD signal for MMC compatibility. The micro SD Card connector built-in card detection switch is not used, since the card must always be inserted for the FunKey S to boot, and the corresponding pins are thus connected to GND. The SD Card power supply is applied through an RC low-pass filter R9 / C11 in order to provide a soft-start operation, as the card built-in large bulk capacitor on its power rail may collapse the supply voltage when initially powered up.","title":"Schematics"},{"location":"developer_guide/hardware_reference/uart/","text":"The Allwinner V3s provides 3x UARTs (Universal Asynchronous Receivers / Transmitters): UART0 with only RX and TX signals, and UART1 and UART2 with additional RTS and CTS hardware flow control signals. Like most SoCs , the Allwinner V3s provides a serial console as a control terminal for debug and/or normal operation. By default, it is mapped to UART0, and it is used by the BROM (Boot Rom), the U-Boot bootloader and by the Linux kernel to output messages during the boot process, and later by the Linux kernel to log messages during normal operation. Depending on the configuration, it can be used too for loging into the system over an UART . The Console schematic only requires a minimum of external components: Besides the 3-pin 1.27 mm (0.05\") pitch header J1 that will not be mounted on standard products, there is only a single series resistor R3 . What is the purpose of this resistor? As explained previously for the SD Card clock signal, this may be to prevent ringing. But given the relatively slow signal speed (115200 bps), it is not the case here If it were placed on the RX input signal, this could prevent frying the input pin if a large voltage (+5V, for example) is applied to it by dissipating the excessive voltage as heat in the resistor. It is not the case here, as the resistor is placed on the TX output signal, but we could have added one, if only we had some space left on the board... But as the V3s SoC can tolerate input voltages up to +3.6V on its pins, we should be safe! In fact, the resistor is on the output TX signal to prevent short-circuits if the serial cable is reversed and the 2 TX outputs are connected together, one driving the signal low, while the other is driving it high: again in this case, the voltage difference between the 2 outputs will be burned as heat in the resistor, saving the internal output buffers! Warning There is no ESD protection TVS diodes on the UART : this interface is not supposed to be mounted in the final user device, and PCB space is really constrained in this area, so they are omitted.","title":"UART"},{"location":"developer_guide/hardware_reference/usb/","text":"In the FunKey S device, the USB interface has 2 functions: provide an external power supply source for both powering the device and charging the built-in LiPo battery provide a data interface to transfer firmware upgrades, configuration files, game emulators and game ROMs The first function only requires the +5V USB power and GND pins. The second function requires to wire the additional differential data lines D+ and D-. As we only need to operate as an USB device and although the V3s is able to work as either an USB host or USB device using the USB OTG protocol, we don't need the ID pin to determine by the cable wiring which role we must take. The main part is of course the Micro USB edge-mounted connector J2 , which we chose in order to \"mask out\" its already low-profile height into the PCB thickness. And with its \"harpoon-like\" through-hole legs, it should avoid tearing it off the board if the user don't pull the chord straight. The USB schematic is the following: Before connecting 2 devices using an USB cable, they may be at completely different absolute voltages, and during cable insertion, the shield will be in contact before the other pins, including GND. The C6 capacitor between the Protective Earth (Shield) and GND is here to provide an AC path for sinking this difference in voltage and align the GND levels when plugin the cable. The resistor R4 on the USB ID connector pin should probably not be mounted: as we act only as an USB device, this pin should be left floating. The capacitors C7 , C8 , C10 and ferrite bead L2 form a constant-k 3 pole CLC low pass filter to remove any spurious in/out on the USB power supply wire. The USB 2.0 specification limits the maximum bulk capacitance value to 10 \u00b5F in order to avoid power supply excessive droops when plugin in a device with a discharged large bulk capacitor. D15 is a NXP PRTR5V0U2X,215 combined TVS protection diode for the VBUS pin and a set of clamping diodes that will limit the voltage on D+ and D- pins to stay between GND and VBUS levels to in order to protect the V3s USB driver from under / over-voltages.","title":"USB"},{"location":"developer_guide/hardware_reference/power/decoupling/","text":"Capacitor Usage \u00b6 So far, we already encountered capacitors for many different usages: Load Capacitors \u00b6 We have seen load capacitors used with the 2 crystals in the discussion about CPU . A quartz crystal always provides both series and parallel resonance, the series resonance being a few kilohertz lower than the parallel one. Crystals below 30 MHz like ours are generally operated between series and parallel resonance, which means that the crystal appears as an inductive reactance in operation, this inductance forming a parallel resonant circuit with externally connected parallel \"load\" capacitance. Any small additional capacitance added in parallel with the crystal pulls the frequency lower in the range between the series and parallel resonance frequencies, insuring crystal startup and stable operation. For modern circuits, these load capacitors have a typical small value < 20 pF. Bulk Capacitors \u00b6 Bulk capacitors are used to prevent a power supply from dropping too far during the periods when current is not available. At the same time, they help to reduce the power supply voltage ripples by smoothing their output voltage. Many such capacitors are used at both the input and output of the numerous linear and switched mode power supplies in the PMIC discussion . The main bulk capacitor value is generally high (some \u00b5F), but there may be smaller parallel capacitors added for stability. Coupling Capacitors \u00b6 As you probably know, capacitors are made of 2 parallel conductive electrodes separated by a (thin) isolating dielectric material (even if these electrodes are rolled or layered to reduce the component size). Thus by construction, no DC (Direct Current) can flow from one electrode to the other, but by influence using the electric field, AC (Alternative Current) still can go through. This is how coupling capacitors are used to link 2 circuits while removing any DC bias voltage on one side or the other of the capacitor. We use such a coupling capacitor in the Audio schematic description for feeding the audio power amplifier from the CPU audio output. Filter Capacitors \u00b6 We have seen many examples where capacitors are used within passive filter circuits along with resistors or inductors, mainly to remove unwanted frequencies from a power supply or a signal. Decoupling (Bypass) Capacitors \u00b6 We use some decoupling capacitors in the buttons circuit . Active components such as transistors and chips are connected to their power supplies through conductors featuring a (small) common impedance made up of complex (resistive, capacitive and inductive) value. Because of these parasitic components, a device that suddenly draws some current in spikes will generate a drop in its voltage power supply. If many devices are sharing the same power supply and impedance, the state of one device will be coupled to the other ones through the common impedance of the power supply conductors and may affect their operation. In order to decouple the devices, capacitors placed as close as possible to the device power supply input pins are used, which act as local energy storage. These capacitors are also named \"bypass capacitors\" as they shunt transient energy from the power supplies past the device to be decoupled, right to the GND return path. There may be different capacitors values placed on the same power supply pins in order to filter transients at different frequencies: the bigger the capacitor value, the lower the frequency. A typical value is 100 nF, and values from 1 \u00b5F to 10 \u00b5F are used for lower frequencies and / or higher current draws, while lower values of a few nF are used for filtering higher frequencies. In essence, decoupling capacitors are not very different in their function from bulk capacitors: the only difference is one of scale, both of current and of transient duration. Bulk capacitors deal with large currents and periods of 10s of ms, whereas decoupling capacitors are used for much lower currents and much briefer periods (typically 10s of ns for TTL or CMOS devices) . Schematics \u00b6 The last part of the FunKey schematics merely contains only decoupling capacitors: One exception is the Allwinner V3s CPU HPR/HPL circuit which features an RC-to-ground circuit between the amplifier and the preamplifier input with the resistor R27 and capacitors C79 and C81 , as recommended in the V3s hardware design guide . The only other remarkable point left in this schematic is the resistor divider R25 / R28 which provides a reference voltage at half the DRAM power supply voltage level, which is used for the integrated DDR2 DRAM merged drivers and dynamic on-chip termination already discussed at the end of the previous CPU schematic description .","title":"Decoupling"},{"location":"developer_guide/hardware_reference/power/decoupling/#capacitor-usage","text":"So far, we already encountered capacitors for many different usages:","title":"Capacitor Usage"},{"location":"developer_guide/hardware_reference/power/decoupling/#load-capacitors","text":"We have seen load capacitors used with the 2 crystals in the discussion about CPU . A quartz crystal always provides both series and parallel resonance, the series resonance being a few kilohertz lower than the parallel one. Crystals below 30 MHz like ours are generally operated between series and parallel resonance, which means that the crystal appears as an inductive reactance in operation, this inductance forming a parallel resonant circuit with externally connected parallel \"load\" capacitance. Any small additional capacitance added in parallel with the crystal pulls the frequency lower in the range between the series and parallel resonance frequencies, insuring crystal startup and stable operation. For modern circuits, these load capacitors have a typical small value < 20 pF.","title":"Load Capacitors"},{"location":"developer_guide/hardware_reference/power/decoupling/#bulk-capacitors","text":"Bulk capacitors are used to prevent a power supply from dropping too far during the periods when current is not available. At the same time, they help to reduce the power supply voltage ripples by smoothing their output voltage. Many such capacitors are used at both the input and output of the numerous linear and switched mode power supplies in the PMIC discussion . The main bulk capacitor value is generally high (some \u00b5F), but there may be smaller parallel capacitors added for stability.","title":"Bulk Capacitors"},{"location":"developer_guide/hardware_reference/power/decoupling/#coupling-capacitors","text":"As you probably know, capacitors are made of 2 parallel conductive electrodes separated by a (thin) isolating dielectric material (even if these electrodes are rolled or layered to reduce the component size). Thus by construction, no DC (Direct Current) can flow from one electrode to the other, but by influence using the electric field, AC (Alternative Current) still can go through. This is how coupling capacitors are used to link 2 circuits while removing any DC bias voltage on one side or the other of the capacitor. We use such a coupling capacitor in the Audio schematic description for feeding the audio power amplifier from the CPU audio output.","title":"Coupling Capacitors"},{"location":"developer_guide/hardware_reference/power/decoupling/#filter-capacitors","text":"We have seen many examples where capacitors are used within passive filter circuits along with resistors or inductors, mainly to remove unwanted frequencies from a power supply or a signal.","title":"Filter Capacitors"},{"location":"developer_guide/hardware_reference/power/decoupling/#decoupling-bypass-capacitors","text":"We use some decoupling capacitors in the buttons circuit . Active components such as transistors and chips are connected to their power supplies through conductors featuring a (small) common impedance made up of complex (resistive, capacitive and inductive) value. Because of these parasitic components, a device that suddenly draws some current in spikes will generate a drop in its voltage power supply. If many devices are sharing the same power supply and impedance, the state of one device will be coupled to the other ones through the common impedance of the power supply conductors and may affect their operation. In order to decouple the devices, capacitors placed as close as possible to the device power supply input pins are used, which act as local energy storage. These capacitors are also named \"bypass capacitors\" as they shunt transient energy from the power supplies past the device to be decoupled, right to the GND return path. There may be different capacitors values placed on the same power supply pins in order to filter transients at different frequencies: the bigger the capacitor value, the lower the frequency. A typical value is 100 nF, and values from 1 \u00b5F to 10 \u00b5F are used for lower frequencies and / or higher current draws, while lower values of a few nF are used for filtering higher frequencies. In essence, decoupling capacitors are not very different in their function from bulk capacitors: the only difference is one of scale, both of current and of transient duration. Bulk capacitors deal with large currents and periods of 10s of ms, whereas decoupling capacitors are used for much lower currents and much briefer periods (typically 10s of ns for TTL or CMOS devices) .","title":"Decoupling (Bypass) Capacitors"},{"location":"developer_guide/hardware_reference/power/decoupling/#schematics","text":"The last part of the FunKey schematics merely contains only decoupling capacitors: One exception is the Allwinner V3s CPU HPR/HPL circuit which features an RC-to-ground circuit between the amplifier and the preamplifier input with the resistor R27 and capacitors C79 and C81 , as recommended in the V3s hardware design guide . The only other remarkable point left in this schematic is the resistor divider R25 / R28 which provides a reference voltage at half the DRAM power supply voltage level, which is used for the integrated DDR2 DRAM merged drivers and dynamic on-chip termination already discussed at the end of the previous CPU schematic description .","title":"Schematics"},{"location":"developer_guide/hardware_reference/power/dram_power/","text":"A separate Sylergy SY8088 Buck DC/DC SMPS chip is used to provide the DDR2 +1V8 DDR2 DRAM power. This is because the AXP20x is originally the PMU (Power Management Unit) used by most Allwinner SoCs (A10, A13 and A20), which do not integrate SDRAM, so the board designer has a wide choice of memory option: DDR2, DDR3, DDR3L, LPDDR3, LPDDR4 with various voltage requirements. But no specific PMIC was created for the Allwinner V3s used in the FunKey device which however integrates a fixed SiP (System In Package) 512Mbit (64MB) DDR2 SDRAM. We thus have to design a separate SMPS (DC-DC) power supply for providing the +1.8V 1A required for the DDR2 DRAM power supply. For this purpose, we followed closely the Allwinner Reference Design . Here is the corresponding DRAM Power schematics: Nothing very fancy here: the SMPS chip U4 has its required input filter capacitor C37 and output capacitors C65 and C73 . The low-profile ferrite-core power inductor L6 (rated with a saturation current of 1.76A and low < 0.1 \u2126 resistance) provides the DC-DC energy storage element. The R20 / R23 precision voltage divider provides the required +0.6V feedback voltage from the +1.8V output voltage by having a \u2153 resistor ratio. The last component is a pull-up resistor R19 which ties the SMPS chip enable input to its active level permanently. The pull-up voltage is +3.0V (just as in the original reference design), probably as it is the next higher voltage available, in order to limit the current in it to its lowest possible value.","title":"DRAM Power"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/","text":"Looking back at the section on the CPU schematics , the FunKey S device clearly needs a sophisticated power supply in order to fulfill the CPU power requirements. They are recalled below, along with the maximum current requirements found in the Allwinner V3s reference design (page 3): +3.3V / 1.2A for the I/O power supply +3.3V_AO / 30 mA for the Always-On power supply ( RTC timer) +3.0V / 200 mA for the analog power supply +1.8V / 1A for the DDR2 DRAM power supply +1.25V / 1.6 A for the core power supply But why in the first place are there so many different power supply voltages required? Power Efficiency \u00b6 A first answer is: for better power efficiency. As P = U x I (Electrical power is the product of voltage level by current intensity), you can reduce power by decreasing the required current or by reducing the operating voltage. Assuming you already do your best to reduce the required current, you can still reduce power by reducing the voltage. Reducing Power Supply Voltage \u00b6 Voltage Drop \u00b6 But how far can you go? Over long distance, you have the voltage drop from the conductor linear resistance, but this effect can be neglected for small boards. Noise Margin \u00b6 You have inductive and capacitive coupling between conductive wires and planes too, but within a PCB , these coupling only have a limited direct effect on voltage. However, these coupling play a role in that they will pick up external electromagnetic noise from the surroundings and inject it into the circuit. And with digital circuits, a critical limit when lowering the operating voltage is the \"noise margin\" or difference in absolute voltage levels between a logical '0' and logical '1', which determines the maximum amplitude of spurious voltage spikes that a conductor can pick up that will trigger an erroneous logic level change. This phenomenon mostly depends on the circuit scale: a long-distance circuit between boards will require higher voltages (typically +12V or +24V) to limit this effect, whereas a circuit between boards a few meters apart or using through-hole chips on the same board wile require a lower voltage (typically +5V like the old Arduinos). Using SMT chips will allow even smaller boards and lower voltages (+3.3V is typical today), and with wires running on the same silicon die, it is possible to go down to +1.2V, given the current technological limits. Voltage Swing \u00b6 There are other reasons why you should try to minimize voltages: the core CPU for example needs to run as fast as possible, and lowering its operating voltage will shorten the signal rise and fall duration as the voltage swing is reduced. Other Power Supply Considerations \u00b6 Besides reducing the operating voltage, there are other considerations that may push to multiply the number of power supplies in a design: Quiescent Current \u00b6 As for power supply used for standby operation providing small currents, a very-low leakage current (\"quiescent current\") is required as it can no longer be neglected compared to the current required by the light load and even more importantly because this current consumption is permanent. Ripple Voltage \u00b6 For sensitive circuits such as ADCs (Analog to Digital Converters) or PLLs (Phase-Locked Loops) which rely on comparing very small voltage differences, a \"clean\" power supply featuring very low ripple voltage amplitude is required to achieve a good resolution and/or accuracy. This characteristic is only possible to obtain using LDOs and not SMPS , and the figure to pay attention to is then the PSRR (Power Supply Rejection Ratio) or how much a variation in the input voltage will affect the output voltage: the higher, the better! A value > 50 dB is a good starting point. Application to the FunKey Design \u00b6 Based on these considerations, it is now clear that each V3s power supply voltage has a good reason to exist: +3.3V / 1.2A is used for powering the I/Os to connect between chips on the board. Given the required current, a SMPS is required for reaching a good efficiency +3.3V_AO / 30 mA for the Always-On power supply ( RTC timer) requires a low quiescent-current, so an LDO is used +3.0V / 200 mA for the analog power supply also requires an LDO , this time to minimize the ripple voltage +1.8V / 1A for the DDR2 DRAM power supply: this strange voltage level is typical for DDR2 DRAM memory chips, and is the result of driving the large memory array inside the chip +1.25V / 1.6 A for powering the CPU core to minimize the voltage swing and increase the possible CPU frequency. Given the required current, a SMPS is required for reaching a good efficiency, too","title":"Multiple Power Supply Voltages"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#power-efficiency","text":"A first answer is: for better power efficiency. As P = U x I (Electrical power is the product of voltage level by current intensity), you can reduce power by decreasing the required current or by reducing the operating voltage. Assuming you already do your best to reduce the required current, you can still reduce power by reducing the voltage.","title":"Power Efficiency"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#reducing-power-supply-voltage","text":"","title":"Reducing Power Supply Voltage"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#voltage-drop","text":"But how far can you go? Over long distance, you have the voltage drop from the conductor linear resistance, but this effect can be neglected for small boards.","title":"Voltage Drop"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#noise-margin","text":"You have inductive and capacitive coupling between conductive wires and planes too, but within a PCB , these coupling only have a limited direct effect on voltage. However, these coupling play a role in that they will pick up external electromagnetic noise from the surroundings and inject it into the circuit. And with digital circuits, a critical limit when lowering the operating voltage is the \"noise margin\" or difference in absolute voltage levels between a logical '0' and logical '1', which determines the maximum amplitude of spurious voltage spikes that a conductor can pick up that will trigger an erroneous logic level change. This phenomenon mostly depends on the circuit scale: a long-distance circuit between boards will require higher voltages (typically +12V or +24V) to limit this effect, whereas a circuit between boards a few meters apart or using through-hole chips on the same board wile require a lower voltage (typically +5V like the old Arduinos). Using SMT chips will allow even smaller boards and lower voltages (+3.3V is typical today), and with wires running on the same silicon die, it is possible to go down to +1.2V, given the current technological limits.","title":"Noise Margin"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#voltage-swing","text":"There are other reasons why you should try to minimize voltages: the core CPU for example needs to run as fast as possible, and lowering its operating voltage will shorten the signal rise and fall duration as the voltage swing is reduced.","title":"Voltage Swing"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#other-power-supply-considerations","text":"Besides reducing the operating voltage, there are other considerations that may push to multiply the number of power supplies in a design:","title":"Other Power Supply Considerations"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#quiescent-current","text":"As for power supply used for standby operation providing small currents, a very-low leakage current (\"quiescent current\") is required as it can no longer be neglected compared to the current required by the light load and even more importantly because this current consumption is permanent.","title":"Quiescent Current"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#ripple-voltage","text":"For sensitive circuits such as ADCs (Analog to Digital Converters) or PLLs (Phase-Locked Loops) which rely on comparing very small voltage differences, a \"clean\" power supply featuring very low ripple voltage amplitude is required to achieve a good resolution and/or accuracy. This characteristic is only possible to obtain using LDOs and not SMPS , and the figure to pay attention to is then the PSRR (Power Supply Rejection Ratio) or how much a variation in the input voltage will affect the output voltage: the higher, the better! A value > 50 dB is a good starting point.","title":"Ripple Voltage"},{"location":"developer_guide/hardware_reference/power/multiple_voltages/#application-to-the-funkey-design","text":"Based on these considerations, it is now clear that each V3s power supply voltage has a good reason to exist: +3.3V / 1.2A is used for powering the I/Os to connect between chips on the board. Given the required current, a SMPS is required for reaching a good efficiency +3.3V_AO / 30 mA for the Always-On power supply ( RTC timer) requires a low quiescent-current, so an LDO is used +3.0V / 200 mA for the analog power supply also requires an LDO , this time to minimize the ripple voltage +1.8V / 1A for the DDR2 DRAM power supply: this strange voltage level is typical for DDR2 DRAM memory chips, and is the result of driving the large memory array inside the chip +1.25V / 1.6 A for powering the CPU core to minimize the voltage swing and increase the possible CPU frequency. Given the required current, a SMPS is required for reaching a good efficiency, too","title":"Application to the FunKey Design"},{"location":"developer_guide/hardware_reference/power/pmic/","text":"From the previous section, we can summarize the V3s power supply requirements to: SMPS for +3.3V / 1.2A for the I/O power supply LDO for +3.3V_AO / 30 mA for the Always-On power supply ( RTC timer) LDO for +3.0V / 200 mA for the analog power supply SMPS for +1.8V / 1A for the DDR2 DRAM power supply SMPS for +1.25V / 1.6 A for the core power supply On the LicheePi Zero board used in our FunKey Zero prototype, a triple SMPS EA3036 is used for generating these +3.3V, +1.8V and +1.2V voltages, with an additional XC6206 LDO for the +3.0V (the +3.3V Always On is connected directly to +3.3V). Although compact (the EA3036 is a tiny 3 mm x 3 mm QFN20 package), this solution is not ideal as it does not provide a battery charger and monitoring capability, which is a requirement for the FunKey S device. PMICs \u00b6 As it is generally the case with such a complex SoC requiring multiple voltages, high current and proper voltage sequencing, all major manufacturers provide dedicated companion chips called PMICs (Power Management Integrated Circuits), in charge of these tasks. Allwinner is not an exception through its sister company X-Powers . Their AXP20x products are highly-integrated PMICs that are optimized for applications requiring single-cell Li-battery (Li-Ion/Polymer), multiple output DC-DC converters and LDOs. Here is a block diagram: The AXP20x features: A wide choice of input power source, the best source is output as IPSOUT inside the IPS (Intelligent Power Select) block: USB VBUS Battery BAT ACIN wall plug (not used in the FunKey S ) BACKUP battery (not used in the FunKey S ) A 1.8A fast PWM battery charger (also called DC/DC1) with battery voltage / current sense and programmable charge indication LED A soft key power-on/off logic with timer (just as in smartphones!) An I2C interface with interrupt signal to communicate with the CPU An optional battery temperature monitoring if the battery is equipped with an NTC resistor (not used in the FunKey S ) A reference voltage A built-in 12-channel 12 bit ADC that measures various voltages and currents data, as well as feeding an internal Coulomb counter and fuel gauge system (more on this later) A \"power OK\" output used to generate the global RESET signal for the FunKey S 5x GPIOs (not used in the FunKey S ), GPIO0 can be programmed as LDO5 output 2x DC/DC SMPS DC-DC2 and DC-DC3 5x LDOs (only 2 are used in the FunKey S , LDO5 is optionnaly output to GPIO0) Looking at their datasheets, it is difficult to tell the difference between the AXP202 , AXP203 and AXP209 (any hint welcome!). In the FunKey S design, we use an AXP209 because it is the one that comes along with the V3s when you buy it on AliExpress. AXP20x Application Diagram \u00b6 For complex dedicated chips like this, the best option is to follow as much as possible the application diagram and reference design given by the manufacturer, as the internals of the chips are seldom fully disclosed, so you need to take their word on some of the external component values to use. The Allwinner V3s Reference Design contains on page 6 the schematics for using an AXP203 to supply the power to a V3s-based dashboard camera design. It follows closely the application diagram provided in the AXP20x datasheets: More hints are provided in our self-translated V3s Hardware Design Guide (page 7) too. PMIC Schematics \u00b6 The FunKey S device uses all of the U5 AXP209 integrated SMPS : the PWM charger DC-DC1 for the battery the DC-DC2 for providing the +1.25 V / 1.6A to the core the DC-DC3 for providing the +3.3V / 1.2A to the I/Os But compared to the sophisticated reference design above, the FunKey S device only uses 2 out of the 5 integrated LDOs: LDO1 supplies the +3.3V / 30 mA Always On for the RTC LDO2 provides the +3.0V / 200 mA for the analog power supply LDO3 / LDO4 / LDO5 are not used in the FunKey S Here are the PMIC schematics: These schematics may look intimidating and complex, but they are in fact just a collection of simple basic elements, and it is actually very close to the manufacturer-recommended design. Here are the details for each PMIC functions, one by one: Power Inputs (East side) \u00b6 A wall-plug AC adapter input is not used in the FunKey S device, so +VIN is just filtered using C75 on pins 32 and 33. The USB power input +VUSB on pin 31 is filtered using C70 , and the best (between +VUSB and +VBAT) available voltage is output to +VOUT on pins 34 and 35 and filtered using C78 . The BACKUP supply on pin 30 is not used and is left unconnected. Internal Connections (All sides) \u00b6 Some AXP20x signals are externally available and should be connected to external components: The BIAS connection on pin 23 is connected to a precision 200k 1% resistor R22 , as recommended The reference voltage VREF on pin 24 is decoupled with C64 The +2.5V internal logic voltage VINT on pin 26 is filtered using the recommended value for C67 Additionally, the AXP20x is actually made up of separate flexible blocks that require external interconnections to set their desired operation: All DC/DC inputs (VIN1 on pin 44, VIN2 on pin 7 and VIN3 on pin 14), as well as LDO3IN input on pin 40 are connected to the best available voltage +VOUT with filter capacitors C59 , C23 , C30 , and C69 , respectively LDO1SET on pin 27 is used to set the initial voltage of LDO1, and according to the datasheets, setting it to VINT sets its voltage to the desired +3.3V for the +3.3V Always On power supply OTOH, combined LDO 2 and 4 input LDOIN24 on pin 13 is instead connected to +3.3V in order to minimize the voltage drop for LDO2 to generate the +3.0V. Here too, there is a filter capacitor C34 It is not clear what is the exact function of APS on pin 21 (it is described as \"Internal Power Input\"), but it must be connected to +VOUT, too DC-DC1 PWM Battery Charger (North East side) \u00b6 The battery is connected to J5 (a 2-pin JST 1.0 mm pitch receptacle ) and uses R21 as a precision current sense resistor, with C53 / C56 / C60 filter capacitors and L5 (a low-profile ferrite-core power inductor rated with a saturation current of 1.2A and low < 0.1 \u2126 resistance). Warning The battery is not protected on the board against reversing polarity, as the model used already contains a built-in protection. R24 is mounted to simulate a battery NTC resistor for measuring temperature, as the chosen LiPo battery does not feature this temperature sensor. A user-programmable (through the I2C interface) charge LED D30 is provided, with its current-limiting resistor R26 , as well as a TVS diode d31 to prevent ESD , as the LED body will be indirectly accessible to user. DC-DC2 +1.25V / 1.6A (West side) \u00b6 This SMPS is built around the ferrite core power inductor L3 and filter capacitors C26 and C29 . DC-DC3 +3.3V / 1.2A (South side) \u00b6 This SMPS is built around the ferrite core power inductor L4 and filter capacitors C39 and C43 . LDO1 +3.3V Always On 30mA (South East side) \u00b6 The LDO output on pin 28 is filtered with capacitor C72 . LDO2 +3.0V / 200mA (South West side) \u00b6 The LDO output on pin 12 is filtered with capacitor C33 . LDO3 (North side) \u00b6 This LDO is not used and its output on pin 41 is nevertheless filtered with a capacitor C63 . LDO4 (South West side) \u00b6 This LDO is not used and its output on pin 11 is nevertheless filtered with a capacitor C38 . Power Key (North West side) \u00b6 The AXP20x features a soft power key with internal short and long-press detection with user-programmable time settings, which enables turning power ON or OFF much like the way it is done in cellular phones. Only a few external components are required: the tactile switch S13 , its ESD protection TVS D29 , and a low-pass filter R18 and C42 for debouncing the switch. I2C Bus (North West side) \u00b6 The AXP20x can be externally controlled by the main CPU using the I2C bus on pins 1 and 2. This bus has pull-up resistors to +3.3V R14 and R16 , and the IRQ /WAKEUP signal on pin 48 enables warning or waking up the CPU on a selection of AXP20x-generated events, with a pull-up resistor R13 to +3.3V. GPIOs (South and West sides) \u00b6 GPIO0-3 on pins 19, 18, 5 and 3 are not used in the FunKey S and are left unconnected. PWROK (South West side) \u00b6 The PWROK signal on pin 25 is used to generate the global RESET signal for the whole board, with a pull-up resistor R15 to the +3.3V Always On power supply and a filter capacitor C18 . Enable Signals (West side) \u00b6 The global chip enable signal N_OE on pin 4 is activated by default through a 47k\u2126 resistor R17 to GND, but a magnetic Reed switch S14 can disable it by forcing its level to +VOUT, with a filter capacitor C83 . This circuit will be disscused later in the Magnetic Switch section . The USB enable signal N_VBUSEN on pin 6 is directly tied to GND to always enable power from the USB bus. Monitoring \u00b6 Through the I2C bus and the numerous internal available registers, the AXP20x provides a very fine control of its operation, including many threshold and timing settings, but also many voltage and curent monitoring values. Coulomb Counters / Fuel Gauge \u00b6 It is well known that battery discharge voltage curve over time is very flat, making it very difficult to estimate the real charge/discharge state of the battery. Moreover, this state will vary with temperature, load, and aging. The only accurate way to monitor the battery status is to actually count the energy that is stored when charging, and the one that is consumed. This particularly important feature is achieved in the AXP20x using a dual Coulomb counter which continuously sums the current intensity over time for monitoring the battery accurate charge and discharge status, with user-defined alert thresholds. This fuel gauge is providing the ability to precisely report the remaining battery capacity, just like people are used to with cellular phones.","title":"PMIC"},{"location":"developer_guide/hardware_reference/power/pmic/#pmics","text":"As it is generally the case with such a complex SoC requiring multiple voltages, high current and proper voltage sequencing, all major manufacturers provide dedicated companion chips called PMICs (Power Management Integrated Circuits), in charge of these tasks. Allwinner is not an exception through its sister company X-Powers . Their AXP20x products are highly-integrated PMICs that are optimized for applications requiring single-cell Li-battery (Li-Ion/Polymer), multiple output DC-DC converters and LDOs. Here is a block diagram: The AXP20x features: A wide choice of input power source, the best source is output as IPSOUT inside the IPS (Intelligent Power Select) block: USB VBUS Battery BAT ACIN wall plug (not used in the FunKey S ) BACKUP battery (not used in the FunKey S ) A 1.8A fast PWM battery charger (also called DC/DC1) with battery voltage / current sense and programmable charge indication LED A soft key power-on/off logic with timer (just as in smartphones!) An I2C interface with interrupt signal to communicate with the CPU An optional battery temperature monitoring if the battery is equipped with an NTC resistor (not used in the FunKey S ) A reference voltage A built-in 12-channel 12 bit ADC that measures various voltages and currents data, as well as feeding an internal Coulomb counter and fuel gauge system (more on this later) A \"power OK\" output used to generate the global RESET signal for the FunKey S 5x GPIOs (not used in the FunKey S ), GPIO0 can be programmed as LDO5 output 2x DC/DC SMPS DC-DC2 and DC-DC3 5x LDOs (only 2 are used in the FunKey S , LDO5 is optionnaly output to GPIO0) Looking at their datasheets, it is difficult to tell the difference between the AXP202 , AXP203 and AXP209 (any hint welcome!). In the FunKey S design, we use an AXP209 because it is the one that comes along with the V3s when you buy it on AliExpress.","title":"PMICs"},{"location":"developer_guide/hardware_reference/power/pmic/#axp20x-application-diagram","text":"For complex dedicated chips like this, the best option is to follow as much as possible the application diagram and reference design given by the manufacturer, as the internals of the chips are seldom fully disclosed, so you need to take their word on some of the external component values to use. The Allwinner V3s Reference Design contains on page 6 the schematics for using an AXP203 to supply the power to a V3s-based dashboard camera design. It follows closely the application diagram provided in the AXP20x datasheets: More hints are provided in our self-translated V3s Hardware Design Guide (page 7) too.","title":"AXP20x Application Diagram"},{"location":"developer_guide/hardware_reference/power/pmic/#pmic-schematics","text":"The FunKey S device uses all of the U5 AXP209 integrated SMPS : the PWM charger DC-DC1 for the battery the DC-DC2 for providing the +1.25 V / 1.6A to the core the DC-DC3 for providing the +3.3V / 1.2A to the I/Os But compared to the sophisticated reference design above, the FunKey S device only uses 2 out of the 5 integrated LDOs: LDO1 supplies the +3.3V / 30 mA Always On for the RTC LDO2 provides the +3.0V / 200 mA for the analog power supply LDO3 / LDO4 / LDO5 are not used in the FunKey S Here are the PMIC schematics: These schematics may look intimidating and complex, but they are in fact just a collection of simple basic elements, and it is actually very close to the manufacturer-recommended design. Here are the details for each PMIC functions, one by one:","title":"PMIC Schematics"},{"location":"developer_guide/hardware_reference/power/pmic/#power-inputs-east-side","text":"A wall-plug AC adapter input is not used in the FunKey S device, so +VIN is just filtered using C75 on pins 32 and 33. The USB power input +VUSB on pin 31 is filtered using C70 , and the best (between +VUSB and +VBAT) available voltage is output to +VOUT on pins 34 and 35 and filtered using C78 . The BACKUP supply on pin 30 is not used and is left unconnected.","title":"Power Inputs (East side)"},{"location":"developer_guide/hardware_reference/power/pmic/#internal-connections-all-sides","text":"Some AXP20x signals are externally available and should be connected to external components: The BIAS connection on pin 23 is connected to a precision 200k 1% resistor R22 , as recommended The reference voltage VREF on pin 24 is decoupled with C64 The +2.5V internal logic voltage VINT on pin 26 is filtered using the recommended value for C67 Additionally, the AXP20x is actually made up of separate flexible blocks that require external interconnections to set their desired operation: All DC/DC inputs (VIN1 on pin 44, VIN2 on pin 7 and VIN3 on pin 14), as well as LDO3IN input on pin 40 are connected to the best available voltage +VOUT with filter capacitors C59 , C23 , C30 , and C69 , respectively LDO1SET on pin 27 is used to set the initial voltage of LDO1, and according to the datasheets, setting it to VINT sets its voltage to the desired +3.3V for the +3.3V Always On power supply OTOH, combined LDO 2 and 4 input LDOIN24 on pin 13 is instead connected to +3.3V in order to minimize the voltage drop for LDO2 to generate the +3.0V. Here too, there is a filter capacitor C34 It is not clear what is the exact function of APS on pin 21 (it is described as \"Internal Power Input\"), but it must be connected to +VOUT, too","title":"Internal Connections (All sides)"},{"location":"developer_guide/hardware_reference/power/pmic/#dc-dc1-pwm-battery-charger-north-east-side","text":"The battery is connected to J5 (a 2-pin JST 1.0 mm pitch receptacle ) and uses R21 as a precision current sense resistor, with C53 / C56 / C60 filter capacitors and L5 (a low-profile ferrite-core power inductor rated with a saturation current of 1.2A and low < 0.1 \u2126 resistance). Warning The battery is not protected on the board against reversing polarity, as the model used already contains a built-in protection. R24 is mounted to simulate a battery NTC resistor for measuring temperature, as the chosen LiPo battery does not feature this temperature sensor. A user-programmable (through the I2C interface) charge LED D30 is provided, with its current-limiting resistor R26 , as well as a TVS diode d31 to prevent ESD , as the LED body will be indirectly accessible to user.","title":"DC-DC1 PWM Battery Charger (North East side)"},{"location":"developer_guide/hardware_reference/power/pmic/#dc-dc2-125v-16a-west-side","text":"This SMPS is built around the ferrite core power inductor L3 and filter capacitors C26 and C29 .","title":"DC-DC2 +1.25V / 1.6A (West side)"},{"location":"developer_guide/hardware_reference/power/pmic/#dc-dc3-33v-12a-south-side","text":"This SMPS is built around the ferrite core power inductor L4 and filter capacitors C39 and C43 .","title":"DC-DC3 +3.3V / 1.2A (South side)"},{"location":"developer_guide/hardware_reference/power/pmic/#ldo1-33v-always-on-30ma-south-east-side","text":"The LDO output on pin 28 is filtered with capacitor C72 .","title":"LDO1 +3.3V Always On 30mA (South East side)"},{"location":"developer_guide/hardware_reference/power/pmic/#ldo2-30v-200ma-south-west-side","text":"The LDO output on pin 12 is filtered with capacitor C33 .","title":"LDO2 +3.0V / 200mA (South West side)"},{"location":"developer_guide/hardware_reference/power/pmic/#ldo3-north-side","text":"This LDO is not used and its output on pin 41 is nevertheless filtered with a capacitor C63 .","title":"LDO3 (North side)"},{"location":"developer_guide/hardware_reference/power/pmic/#ldo4-south-west-side","text":"This LDO is not used and its output on pin 11 is nevertheless filtered with a capacitor C38 .","title":"LDO4 (South West side)"},{"location":"developer_guide/hardware_reference/power/pmic/#power-key-north-west-side","text":"The AXP20x features a soft power key with internal short and long-press detection with user-programmable time settings, which enables turning power ON or OFF much like the way it is done in cellular phones. Only a few external components are required: the tactile switch S13 , its ESD protection TVS D29 , and a low-pass filter R18 and C42 for debouncing the switch.","title":"Power Key (North West side)"},{"location":"developer_guide/hardware_reference/power/pmic/#i2c-bus-north-west-side","text":"The AXP20x can be externally controlled by the main CPU using the I2C bus on pins 1 and 2. This bus has pull-up resistors to +3.3V R14 and R16 , and the IRQ /WAKEUP signal on pin 48 enables warning or waking up the CPU on a selection of AXP20x-generated events, with a pull-up resistor R13 to +3.3V.","title":"I2C Bus (North West side)"},{"location":"developer_guide/hardware_reference/power/pmic/#gpios-south-and-west-sides","text":"GPIO0-3 on pins 19, 18, 5 and 3 are not used in the FunKey S and are left unconnected.","title":"GPIOs (South and West sides)"},{"location":"developer_guide/hardware_reference/power/pmic/#pwrok-south-west-side","text":"The PWROK signal on pin 25 is used to generate the global RESET signal for the whole board, with a pull-up resistor R15 to the +3.3V Always On power supply and a filter capacitor C18 .","title":"PWROK (South West side)"},{"location":"developer_guide/hardware_reference/power/pmic/#enable-signals-west-side","text":"The global chip enable signal N_OE on pin 4 is activated by default through a 47k\u2126 resistor R17 to GND, but a magnetic Reed switch S14 can disable it by forcing its level to +VOUT, with a filter capacitor C83 . This circuit will be disscused later in the Magnetic Switch section . The USB enable signal N_VBUSEN on pin 6 is directly tied to GND to always enable power from the USB bus.","title":"Enable Signals (West side)"},{"location":"developer_guide/hardware_reference/power/pmic/#monitoring","text":"Through the I2C bus and the numerous internal available registers, the AXP20x provides a very fine control of its operation, including many threshold and timing settings, but also many voltage and curent monitoring values.","title":"Monitoring"},{"location":"developer_guide/hardware_reference/power/pmic/#coulomb-counters-fuel-gauge","text":"It is well known that battery discharge voltage curve over time is very flat, making it very difficult to estimate the real charge/discharge state of the battery. Moreover, this state will vary with temperature, load, and aging. The only accurate way to monitor the battery status is to actually count the energy that is stored when charging, and the one that is consumed. This particularly important feature is achieved in the AXP20x using a dual Coulomb counter which continuously sums the current intensity over time for monitoring the battery accurate charge and discharge status, with user-defined alert thresholds. This fuel gauge is providing the ability to precisely report the remaining battery capacity, just like people are used to with cellular phones.","title":"Coulomb Counters / Fuel Gauge"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/","text":"Simple DC electronic circuits can be powered by directly connecting a battery. However, more complex circuits usually require a constant input voltage for proper operation. This page is a small sidetrack to explain the different regulated DC power supply topologies, before looking at the FunKey S power supply schematics in details. If you are already comfortable with this subject, you can skip this section entirely! Linear Regulators \u00b6 The easiest method to achieve a constant voltage viewed from the load despite a varying source voltage is to linearly control the resistance of the regulator in accordance with the load, resulting in a constant output voltage. Shunt Regulator \u00b6 The simplest voltage regulator is the shunt regulator , built around a Zener diode which most interesting characteristic is to maintain a constant voltage across itself when the current through it is sufficient to take it into the Zener breakdown region. A simple shunt regulator looks like this: Series Regulator \u00b6 By adding a emitter-follower transistor to the simple shunt regulator, the small base current of the transistor forms a very light load on the Zener, thereby minimizing variation in Zener voltage due to variation in the load, resulting in a better regulation. Here is a schematic for this series regulator : Integrated Linear Regulator \u00b6 In integrated voltage regulators, the discrete Zener diode is replaced by a more sophisticated (but easier to integrate) circuit built around a resistor divider feeding an operational amplifier, a voltage reference, and a transistor driving the emitter-follower pass transistor: Usually, the pass transistor and its driving transistor are combined into a single Darlington transistor plus a controllable current source like this: LDO (Low Drop-Out) Regulator \u00b6 The above circuit works well, but its drop-out voltage (the difference between the input and output voltage) is rather high because of this transistor cascade, around 1.5V to 2.5V. By replacing the emitter-follower Darlington transistor by a PNP transistor in an open collector or open drain topology, the drop-out voltage is reduced to 0.7V or lower: SMPS (Switched-Mode Power Supply) or DC/DC Converters \u00b6 A linear regulator provides the desired output voltage by dissipating excess power as heat in the Zener diode or in the pass transistor. Hence its maximum power efficiency is VOUT/ VIN since the voltage difference is wasted to heat the birds. In contrast, a Switched-Mode Power Supply changes output voltage and current by switching non-linear storage elements, such as inductors, transformers and capacitors between different electrical configurations. These elements are said to be non-linear because the inductor and transformer respond to changes in current by inducing its own voltage to counter the change in current, whereas a capacitor responds to changes in voltage by inducing its own current to counter the change in voltage. Thus, depending on the way the components are arranged, it is possible to obtain SMPS circuits that either have an output voltage higher than the input voltage (\"Boost Converters\"), or lower than the input voltage (\"Buck Converters\", as is it subtracts or \u201cBucks\u201d the supply voltage). Because of technology, power inductors are easier to manufacture, take less space and are more stable over time than their counterpart capacitors. This is why most power DC/DC converters are built using inductors. Capacitor-based SMPS are generally used for lower power applications, such as for generating the +12V and -12V voltages required by true RS232 from a +3.3V or +5V power supply in the ubiquitous MAX232 drivers. Boost Converter \u00b6 The most basic circuit for the Boost converter is the following: If the switch is driven by a square wave, the peak-to-peak voltage of the waveform measured across the switch can exceed the input voltage from the DC source. This is because the non-linear characteristic of the inductor, and this voltage adds to the source voltage while the switch is open. Warning In this converter, the output voltage is not isolated from the input voltage. Buck Converter \u00b6 The corresponding basic circuit for the Buck converter is the following: The way this converter works is described in details here . Basically, when the switch is closed, the inductor will produce an opposing voltage across its terminals in response to the changing current, reducing the output voltage, and meanwhile the inductor stores this energy in the form of a magnetic field. When the switch is opened, the current will decrease and will produce a voltage drop across the inductor, and now the inductor becomes a current source, where the stored energy in the inductor's magnetic field is restored and fed to the load. Warning In this converter too, the output voltage is not isolated from the input voltage. Isolated SMPS \u00b6 Isolated Switched-Mode Power Supplies use a transformer to isolate the input voltage from the output voltage, and thus can produce an output of higher or lower voltage than the input by adjusting the turns ratio. Pros and Cons \u00b6 Linear regulators are simpler than SMPS , and their linear behavior produce a very clean output voltage, but their efficiency is directly proportional to the difference between the input and output voltage, which is dissipated as heat. However, for light loads and/or when the voltage drop-out is low, LDOs are very useful. OTOH, SMPS are more complex and require more components, but their efficiency is much better (typically 80-90%), resulting in less heat, with the drawback of a switching electrical noise pollution of both the input voltage (that may couple electrical switching noise back onto the mains power line) and the output voltage (with electromagnetic interference (EMI) and a ripple voltage at the switching frequency and all its harmonic frequencies). SMPS are thus almost exclusively used when heavy loads are used and/or when the voltage drop-out is important.","title":"Regulated DC Power Supply Topologies"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#linear-regulators","text":"The easiest method to achieve a constant voltage viewed from the load despite a varying source voltage is to linearly control the resistance of the regulator in accordance with the load, resulting in a constant output voltage.","title":"Linear Regulators"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#shunt-regulator","text":"The simplest voltage regulator is the shunt regulator , built around a Zener diode which most interesting characteristic is to maintain a constant voltage across itself when the current through it is sufficient to take it into the Zener breakdown region. A simple shunt regulator looks like this:","title":"Shunt Regulator"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#series-regulator","text":"By adding a emitter-follower transistor to the simple shunt regulator, the small base current of the transistor forms a very light load on the Zener, thereby minimizing variation in Zener voltage due to variation in the load, resulting in a better regulation. Here is a schematic for this series regulator :","title":"Series Regulator"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#integrated-linear-regulator","text":"In integrated voltage regulators, the discrete Zener diode is replaced by a more sophisticated (but easier to integrate) circuit built around a resistor divider feeding an operational amplifier, a voltage reference, and a transistor driving the emitter-follower pass transistor: Usually, the pass transistor and its driving transistor are combined into a single Darlington transistor plus a controllable current source like this:","title":"Integrated Linear Regulator"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#ldo-low-drop-out-regulator","text":"The above circuit works well, but its drop-out voltage (the difference between the input and output voltage) is rather high because of this transistor cascade, around 1.5V to 2.5V. By replacing the emitter-follower Darlington transistor by a PNP transistor in an open collector or open drain topology, the drop-out voltage is reduced to 0.7V or lower:","title":"LDO (Low Drop-Out) Regulator"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#smps-switched-mode-power-supply-or-dcdc-converters","text":"A linear regulator provides the desired output voltage by dissipating excess power as heat in the Zener diode or in the pass transistor. Hence its maximum power efficiency is VOUT/ VIN since the voltage difference is wasted to heat the birds. In contrast, a Switched-Mode Power Supply changes output voltage and current by switching non-linear storage elements, such as inductors, transformers and capacitors between different electrical configurations. These elements are said to be non-linear because the inductor and transformer respond to changes in current by inducing its own voltage to counter the change in current, whereas a capacitor responds to changes in voltage by inducing its own current to counter the change in voltage. Thus, depending on the way the components are arranged, it is possible to obtain SMPS circuits that either have an output voltage higher than the input voltage (\"Boost Converters\"), or lower than the input voltage (\"Buck Converters\", as is it subtracts or \u201cBucks\u201d the supply voltage). Because of technology, power inductors are easier to manufacture, take less space and are more stable over time than their counterpart capacitors. This is why most power DC/DC converters are built using inductors. Capacitor-based SMPS are generally used for lower power applications, such as for generating the +12V and -12V voltages required by true RS232 from a +3.3V or +5V power supply in the ubiquitous MAX232 drivers.","title":"SMPS (Switched-Mode Power Supply) or DC/DC Converters"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#boost-converter","text":"The most basic circuit for the Boost converter is the following: If the switch is driven by a square wave, the peak-to-peak voltage of the waveform measured across the switch can exceed the input voltage from the DC source. This is because the non-linear characteristic of the inductor, and this voltage adds to the source voltage while the switch is open. Warning In this converter, the output voltage is not isolated from the input voltage.","title":"Boost Converter"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#buck-converter","text":"The corresponding basic circuit for the Buck converter is the following: The way this converter works is described in details here . Basically, when the switch is closed, the inductor will produce an opposing voltage across its terminals in response to the changing current, reducing the output voltage, and meanwhile the inductor stores this energy in the form of a magnetic field. When the switch is opened, the current will decrease and will produce a voltage drop across the inductor, and now the inductor becomes a current source, where the stored energy in the inductor's magnetic field is restored and fed to the load. Warning In this converter too, the output voltage is not isolated from the input voltage.","title":"Buck Converter"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#isolated-smps","text":"Isolated Switched-Mode Power Supplies use a transformer to isolate the input voltage from the output voltage, and thus can produce an output of higher or lower voltage than the input by adjusting the turns ratio.","title":"Isolated SMPS"},{"location":"developer_guide/hardware_reference/power/power_supplies_topologies/#pros-and-cons","text":"Linear regulators are simpler than SMPS , and their linear behavior produce a very clean output voltage, but their efficiency is directly proportional to the difference between the input and output voltage, which is dissipated as heat. However, for light loads and/or when the voltage drop-out is low, LDOs are very useful. OTOH, SMPS are more complex and require more components, but their efficiency is much better (typically 80-90%), resulting in less heat, with the drawback of a switching electrical noise pollution of both the input voltage (that may couple electrical switching noise back onto the mains power line) and the output voltage (with electromagnetic interference (EMI) and a ripple voltage at the switching frequency and all its harmonic frequencies). SMPS are thus almost exclusively used when heavy loads are used and/or when the voltage drop-out is important.","title":"Pros and Cons"},{"location":"developer_guide/software_reference/","text":"The FunKey S retro-gaming console software contains a set of console emulators, standalone games, applications and utilities using a custom Operating System (OS) that from now on will be referenced as FunKey-OS . The FunKey-OS is a Linux-based operating system, optimized for the FunKey-S hardware, with a special focus on performance and fast boot time. Instant Action \u00b6 The FunKey S introduces a unique feature called Instant Action , which enables automatically saving the running state when closing the console before turning it off, and restoring this state when opening and turning it back on in a matter of seconds. This feature is only possible because of the optimized fast boot time detailed in the Boot Process section. Storage \u00b6 The only storage system available in the FunKey S is its integrated MicroSD card. Most of its contents is made available to a host computer when connected over USB . The MicroSD card format is detailed in the Disk Partition section. Video Processing \u00b6 The FunKey-S CPU does not feature a GPU . For this reason, the FunKey-S cannot use a hardware-accelerated OpenGL engine, and adding a software-emulated OpenGL-ES engine is not efficient, given the limited CPU performance. However, because of the small screen size and the fact that all applications are used in full-screen mode only, there is no need for a full-blown windowing system like X11, which greatly simplifies the video processing as no window overlapping or frame decoration is thus required. Instead, all graphical computations are performed by the CPU itself, directly into the video frame buffer that will be sent to the screen for display. User Input \u00b6 The FunKey S has no standard keyboard but features common console-oriented controls in the form of a D-Pad, A/B/X/Y Pad, Menu/On/Off, Fn and Start buttons.","title":"Software Reference"},{"location":"developer_guide/software_reference/#instant-action","text":"The FunKey S introduces a unique feature called Instant Action , which enables automatically saving the running state when closing the console before turning it off, and restoring this state when opening and turning it back on in a matter of seconds. This feature is only possible because of the optimized fast boot time detailed in the Boot Process section.","title":"Instant Action"},{"location":"developer_guide/software_reference/#storage","text":"The only storage system available in the FunKey S is its integrated MicroSD card. Most of its contents is made available to a host computer when connected over USB . The MicroSD card format is detailed in the Disk Partition section.","title":"Storage"},{"location":"developer_guide/software_reference/#video-processing","text":"The FunKey-S CPU does not feature a GPU . For this reason, the FunKey-S cannot use a hardware-accelerated OpenGL engine, and adding a software-emulated OpenGL-ES engine is not efficient, given the limited CPU performance. However, because of the small screen size and the fact that all applications are used in full-screen mode only, there is no need for a full-blown windowing system like X11, which greatly simplifies the video processing as no window overlapping or frame decoration is thus required. Instead, all graphical computations are performed by the CPU itself, directly into the video frame buffer that will be sent to the screen for display.","title":"Video Processing"},{"location":"developer_guide/software_reference/#user-input","text":"The FunKey S has no standard keyboard but features common console-oriented controls in the form of a D-Pad, A/B/X/Y Pad, Menu/On/Off, Fn and Start buttons.","title":"User Input"},{"location":"developer_guide/software_reference/input_mapping/","text":"","title":"Input Mapping"},{"location":"developer_guide/software_reference/video_processing/","text":"","title":"Video Processing"},{"location":"developer_guide/software_reference/boot_process/","text":"Quote Analyzing the boot processes of systems that are functioning well prepares users and developers to deal with the inevitable failures. Alison Chaiken in \" Analyzing the Linux boot process \" Learning how the FunKey S boots and shuts down is not required in order to develop for this platform, but it is certainly an interesting experience in order to understand the way to optimize a Linux embedded system. And then, when something goes wrong, it provides some useful insight on where to find the solution... Startup Process \u00b6 The startup process for a Linux machine is like a space rocket launch, but in reverse order: you start small and end up big, each stage helping to launch the next one. The reason for this is because many resources are involved when booting a Linux system, that require a significant amount of set up before you can use them, as they are not available right from the beginning; the most critical ones are probably memory and system clocks. When the FunKey S is started, its CPU is merely as powerful as an Arduino board: what is available is a 32-bit ARM CPU running @ 24MHz, with no reliable memory besides its 30 internal registers and a 32KB boot ROM . In order to get up to full speed (1.2GHz) and with all its memory (64MB DRAM , access to the 8GB SDcard) requires several steps, in order: The Boot ROM The SPL (Secondary Program Loader) The U-Boot bootloader The Linux kernel The userland System V init scripts Shutdown Process \u00b6 Unlike the startup process, the shutdown process is much more straightforward, but it must be optimized to run as quiclky as possible, as the time from when the shutdown is initiated when the user press the key or close the FunKey S lid to actual poweroff is extremely short (3 s).","title":"Boot Process"},{"location":"developer_guide/software_reference/boot_process/#startup-process","text":"The startup process for a Linux machine is like a space rocket launch, but in reverse order: you start small and end up big, each stage helping to launch the next one. The reason for this is because many resources are involved when booting a Linux system, that require a significant amount of set up before you can use them, as they are not available right from the beginning; the most critical ones are probably memory and system clocks. When the FunKey S is started, its CPU is merely as powerful as an Arduino board: what is available is a 32-bit ARM CPU running @ 24MHz, with no reliable memory besides its 30 internal registers and a 32KB boot ROM . In order to get up to full speed (1.2GHz) and with all its memory (64MB DRAM , access to the 8GB SDcard) requires several steps, in order: The Boot ROM The SPL (Secondary Program Loader) The U-Boot bootloader The Linux kernel The userland System V init scripts","title":"Startup Process"},{"location":"developer_guide/software_reference/boot_process/#shutdown-process","text":"Unlike the startup process, the shutdown process is much more straightforward, but it must be optimized to run as quiclky as possible, as the time from when the shutdown is initiated when the user press the key or close the FunKey S lid to actual poweroff is extremely short (3 s).","title":"Shutdown Process"},{"location":"developer_guide/software_reference/boot_process/boot_rom/","text":"According to the Allwinner V3s datasheet , the integrated boot system consists in a 32KB boot ROM mapped at addresses 0xffff0000-0xffff7fff , that can boot from SPI NOR Flash, SPI NAND Flash, SD Card and USB . In Allwinner terminology, this boot ROM is called \" BROM \" (for \"Boot ROM \") or \" eGON.BRM \" (for \"Embedded GO-ON Bootloader Boot ROM \", who knows what this means exactly?). But in another place in the same datasheet, it is stated that it can boot from eMMC, too. Wrong! We found that the available information is either incomplete, inacurate, misleading or completely false . What triggered our suspicion was this first mismatch and the lack of details regarding the boot process: not a single explanation on the boot firmware format and/or exact location. The original v3s_lichee.zip SDK is not very helpful in this regard. Hopefully, as Allwinner tends to use a rather consistent similar boot process for all its SoCs , the lichee-v2.0.tar.gz from Olimex is actually giving some clues, albeit it does not mention the V3s. But the best source of information on the Allwinner chips is certainly the sunxi community , that is dedicated to gather information around the Allwinner SoCs . And although it describes in details the Allwinner A10/A20 and A31 chips and not the V3s, their BROM page is a golden mine. The A20-V1.2.tar.gz SDK from Olimex is also relevant, as it contains some original source code for the Allwinner A20 SoC bootloader. Eventually, in order to clear all doubts regarding the Boot ROM role, we had to reverse-engineer the Allwinner V3s Boot ROM by disassembling its source code. The current findings are available in our repository, in the \" brom.s \" file, with our comments added: https://github.com/FunKey-Project/Allwinner-V3s-BROM Power-On Reset (POR) \u00b6 As it is common to all ARM Cortex-A architecture CPUs , the Allwinner V3s fetches the first instruction to execute from the first 32-bit word in a vector table located at address 0xffff0000 . On the V3s, this location is the first 32-bit word in the Boot ROM , that contains as its first vector a branch instruction to the reset function \", located immediately after the vector table. And except for the irq vector that contains a branch instruction to the first-level routine handling interrupt request , all other standard ARM vectors only contain a branch to a \" forever loop \" as they are not implemented at this stage. Note A non-standard \"FEL\" vector is appended at the end of the vector table. This provides an indirect way to access the FEL code, allowing to change its actual location while keeping the ability to address it using a fixed location. Reset Function \u00b6 The reset function is the first useful piece of code executed on the CPU . At this point, the only known-working hardware is the CPU 24 MHz clock derived from the external crystal, the CPU itself and its internal registers which may not even be initialized. Register Initialization \u00b6 This is the role of the short reset function that clears all CPU registers (except r0 that is set to 1 ) and jumps to the actual BROM header first 32-bit word. BROM Header \u00b6 The BROM location contains a \"BROM header\" structure made up of: a 32-bit word branch instruction that jumps to the start function an ASCII magic signature \" eGON.BRM \" a header length in bytes (32) a boot version in ASCII (\"1100\" for version 1.1.00) an eGON version in ASCII (\"1100\" for version 1.1.00) a platform information in ASCII (\"1681\" for the V3s) a 32-bit word padding Start Function \u00b6 The start function role is to setup a minimal execution environment with a call stack, using the internal static RAM A1 and C memory. BROM Output Pin Toggling \u00b6 We found that the first step of the start function consists in toggling an unidentified \"BROM Output\" pin. This guess is based on the fact that, according to the H6 User Manual which has a register with similar offset ( 0xa4 ) in its system configuration block, it is indeed BROM_OUTPUT_REG , and its bit 0 is BROM_OUTPUT_ENABLE , and bit 1 is BROM_OUTPUT_VALUE . Tip If this pin is actually available, this would allow to check with an oscilloscope if the CPU is running or not, but we were not able to locate it. Multi- CPU Check \u00b6 The second step in the start function is to check for multi- CPUs . This is unlikely to do anything, as the V3s only contains a single CPU , but the code is probably here for compatibility with other multi-core SoCs . Start CPU #0 \u00b6 The third step in the start function is to initialize the CPU #0 operating mode : define the system as an ARMv4+ architecture set the CPU #0 in SVC (supervisor) mode disable both normal IRQ and fast FIRQ interrupt requests set the system as little-endian Disable Memory Access Features \u00b6 The next step in the start function is to disable all kind of memory access optimization features : disable the MMU disable the data cache (D-Cache) disable the program flow prediction and the instruction cache (I-Cache) Disable Watchdog \u00b6 The next step in sequence in the start function is to disable the watchdog . Tip However, this is described in the datasheet as having \"no effect\"? It may be a write-once capability that is disabled when written anything but zeros. Configure Internal System Bus Clocks \u00b6 The clocks for the AHB1 (Advanced High-speed Bus #1) and APB1 (Advanced Peripheral Bus #1) bus clocks are set up to enable access to most of the internal peripheral controllers, except UART , TWI that are on APB2 bus and EMAC and USB that are on AHB2 bus, as can be seen in the diagram below: Bug In the above diagram taken from the datasheet, the BROM looks like is located on the APB1 bus, which is certainly not possible, as the system already accesses it before enabling its clock! Initialize DMA and PIO \u00b6 In the next step in the start function: the DMA engine is enabled the PIO (Peripheral I/O ) controller is enabled to access external pins the DMA engine is reset Initialize Stack Pointer in SRAM A1 \u00b6 At this stage, the 16KB SRAM A1 is available at addresses 0x00000000-0x00003fff , so a first stack pointer is initialized at the top of SRAM A1 memory . Resume from Standby Mode \u00b6 A check is then performed to see if the CPU is resuming from standby mode. Hint This standby mode is not documented anywhere! If yes, a jump to the resume_from_standby function is done, where further checking is performed on the resume header: check for a \" eGON.BT0 \" signature at an address 0x01f01da8 that is suspected to be a \" standby resume entry address register \" check if the resume address the follows the signature is valid (if its 10 MSB bits are all zeros) verify the header checksum If all these checks passed, the resume entry point is called, otherwise a call to the boot function is performed to try to resume the normal boot sequence. Bug However, the normal boot sequence will not be able to continue, as the next steps to enable the SRAM C block are skipped, so this is expected to fail! Enable SRAM C \u00b6 In the next to final step of the start function, the SRAM C (44 KB) is enabled at addresses 0x00004000-0x000efff : first, an undocumented register in System Control block is cleared , that is suspected to enable SRAM C access to the CPU and the DMA Then the Video Engine (VE) is started by enabling its clock and reseting it. It is suspected that the reason it is done here is because the SRAM C block is tied to the Video Engine function Initialize Stack Pointer in SRAM C \u00b6 In the last step of the start function, the stack pointer is set 4KB below the end of SRAM C (address 0x0000dffc ), before calling the final boot function . Boot Function \u00b6 The role of the boot function is to implement the boot sequence described in the datasheet: Wrong! However, we found out that this diagram is inacurate! Check UBoot Button \u00b6 The first step in the boot function is to check if an \"UBoot button\" is pressed by calling the check_uboot function . Note Here, \"UBoot\" stands for \" USB Boot\", it has nothing to do whith \"Das U-Boot\" bootloader! However, as the check_uboot function uses a special register to check the input pin rather than the standard PIO controller, it is not possible to determine from the code which pin is actually involved. We are not aware of any pin on the V3s that has this capability, although we suspected the PF6 pin (pin 100) to have this function as it has no alternate function like all the other pins, but this is not the case: pulling this pin to GND during the boot process has no effect, so likely, this function is not implemented on the V3s. If this hypothetical button is pressed during the boot sequence, the boot function would branch directly to the FEL USB Boot code, bypassing the normal boot process. Boot from Flash Memory \u00b6 Unlike what is describe in the control flow diagram above, the V3s search order for the Flash memory to boot from is actually the following: SD Card on SDC0 interface eMMC chip on SDC2 interface SD Card on SDC2 interface NOR Flash chip on SPI interface NAND Flash chip on SPI interface For all Flash memory types, the boot process is similar: read one 512 byte block at address 0x00000000 from the Flash device to get a \" BOOT0 Header \" check the \" eGON.BT0 \" signature at the very beginning of the loaded block using the check_magic function ( example for booting from MMC0 ) check the length field at offset 16: the second stage bootloader length must be < 32KB (0x8000), example for booting from MMC0 check if the length field bits 24:31 are null (which is always true anyway because of the test above, example for booting from MMC0 ) perform 2 attempts to read the required number of 512-byte blocks for the specified length and load them at address 0x00000000 from the Flash device (it looks like the first block is re-read, example for booting from MMC0 ). The reason to perform 2 attempts is unknown eventually, jump to the .boot_spl function , which: loads 0xfc into register r1 and 0x0 into register r0 calls the jump_spl function that: saves the r0 contents to r4 calls in turn the jump_to function that: loads r0 into the program counter and never returns, actually launching the loaded SPL (Secondary Program Loader) at address 0x00000000 in SRAM A1 and C If no bootable Flash memory is found, the boot function will branch to the FEL USB Boot code. Booting from SD Card \u00b6 As on the FunKey S the only available Flash memory to boot from is the SD Card, we will focus on this one and ignore the other devices. The only SD Card specificity regarding the boot process is that the BOOT0 header above is fetched from 2 byte-offsets from the beginning of the card: at offset 8KB at offset 128KB The reason why these particular offsets were chosen is unknown, but they are not very convenient for card following a standard partitioning scheme: the 8KB offset falls in the middle of the Primary GPT in a GUID Partition Table scheme. As most SD Card are optimized in hardware for the old MBR scheme, it is not critical both offsets fall within the first 1GB on the disk, which is most of the time not allocated for disk partitions, so they require specific tools to access them On the FunKey S , the 8KB offset is used for the SPL , detailed in the next section. The SD Card interface used (0 or 2) is stored into the BOOT0 header in the byte at offset 40, and bit 5 in this byte is set to 1 when the BOOT0 header is loaded from offset 128 KB, and to 0 when booted from offset 8KB by this code . FEL \u00b6 The FEL is a low-level subroutine also contained in the BootROM on Allwinner devices. It is used for initial programming and recovery of devices using USB . The FEL is actually implementing a tiny USB stack for a proprietary USB protocol different from the standard DFU (Device Firmware Update) protocol used by many other devices. Using some specific tools on the host computer, it is possible to read or write data to/from the device over USB and execute code on it, providing a way to boot the system over USB . These \"sunxi-tools\" are described here and here . Warning For the V3s, it is mandatory to build the version from the repository , as the versions packaged in the different operating systems are too old and do not take into account the V3s chip. Using the \"sunxi-tools\" and the built-in FEL mode from the BootROM, it is possible to boot the V3s CPU over USB without any attached Flash storage.","title":"Boot ROM"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#power-on-reset-por","text":"As it is common to all ARM Cortex-A architecture CPUs , the Allwinner V3s fetches the first instruction to execute from the first 32-bit word in a vector table located at address 0xffff0000 . On the V3s, this location is the first 32-bit word in the Boot ROM , that contains as its first vector a branch instruction to the reset function \", located immediately after the vector table. And except for the irq vector that contains a branch instruction to the first-level routine handling interrupt request , all other standard ARM vectors only contain a branch to a \" forever loop \" as they are not implemented at this stage. Note A non-standard \"FEL\" vector is appended at the end of the vector table. This provides an indirect way to access the FEL code, allowing to change its actual location while keeping the ability to address it using a fixed location.","title":"Power-On Reset (POR)"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#reset-function","text":"The reset function is the first useful piece of code executed on the CPU . At this point, the only known-working hardware is the CPU 24 MHz clock derived from the external crystal, the CPU itself and its internal registers which may not even be initialized.","title":"Reset Function"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#register-initialization","text":"This is the role of the short reset function that clears all CPU registers (except r0 that is set to 1 ) and jumps to the actual BROM header first 32-bit word.","title":"Register Initialization"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#brom-header","text":"The BROM location contains a \"BROM header\" structure made up of: a 32-bit word branch instruction that jumps to the start function an ASCII magic signature \" eGON.BRM \" a header length in bytes (32) a boot version in ASCII (\"1100\" for version 1.1.00) an eGON version in ASCII (\"1100\" for version 1.1.00) a platform information in ASCII (\"1681\" for the V3s) a 32-bit word padding","title":"BROM Header"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#start-function","text":"The start function role is to setup a minimal execution environment with a call stack, using the internal static RAM A1 and C memory.","title":"Start Function"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#brom-output-pin-toggling","text":"We found that the first step of the start function consists in toggling an unidentified \"BROM Output\" pin. This guess is based on the fact that, according to the H6 User Manual which has a register with similar offset ( 0xa4 ) in its system configuration block, it is indeed BROM_OUTPUT_REG , and its bit 0 is BROM_OUTPUT_ENABLE , and bit 1 is BROM_OUTPUT_VALUE . Tip If this pin is actually available, this would allow to check with an oscilloscope if the CPU is running or not, but we were not able to locate it.","title":"BROM Output Pin Toggling"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#multi-cpu-check","text":"The second step in the start function is to check for multi- CPUs . This is unlikely to do anything, as the V3s only contains a single CPU , but the code is probably here for compatibility with other multi-core SoCs .","title":"Multi-CPU Check"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#start-cpu-0","text":"The third step in the start function is to initialize the CPU #0 operating mode : define the system as an ARMv4+ architecture set the CPU #0 in SVC (supervisor) mode disable both normal IRQ and fast FIRQ interrupt requests set the system as little-endian","title":"Start CPU #0"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#disable-memory-access-features","text":"The next step in the start function is to disable all kind of memory access optimization features : disable the MMU disable the data cache (D-Cache) disable the program flow prediction and the instruction cache (I-Cache)","title":"Disable Memory Access Features"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#disable-watchdog","text":"The next step in sequence in the start function is to disable the watchdog . Tip However, this is described in the datasheet as having \"no effect\"? It may be a write-once capability that is disabled when written anything but zeros.","title":"Disable Watchdog"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#configure-internal-system-bus-clocks","text":"The clocks for the AHB1 (Advanced High-speed Bus #1) and APB1 (Advanced Peripheral Bus #1) bus clocks are set up to enable access to most of the internal peripheral controllers, except UART , TWI that are on APB2 bus and EMAC and USB that are on AHB2 bus, as can be seen in the diagram below: Bug In the above diagram taken from the datasheet, the BROM looks like is located on the APB1 bus, which is certainly not possible, as the system already accesses it before enabling its clock!","title":"Configure Internal System Bus Clocks"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#initialize-dma-and-pio","text":"In the next step in the start function: the DMA engine is enabled the PIO (Peripheral I/O ) controller is enabled to access external pins the DMA engine is reset","title":"Initialize DMA and PIO"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#initialize-stack-pointer-in-sram-a1","text":"At this stage, the 16KB SRAM A1 is available at addresses 0x00000000-0x00003fff , so a first stack pointer is initialized at the top of SRAM A1 memory .","title":"Initialize Stack Pointer in SRAM A1"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#resume-from-standby-mode","text":"A check is then performed to see if the CPU is resuming from standby mode. Hint This standby mode is not documented anywhere! If yes, a jump to the resume_from_standby function is done, where further checking is performed on the resume header: check for a \" eGON.BT0 \" signature at an address 0x01f01da8 that is suspected to be a \" standby resume entry address register \" check if the resume address the follows the signature is valid (if its 10 MSB bits are all zeros) verify the header checksum If all these checks passed, the resume entry point is called, otherwise a call to the boot function is performed to try to resume the normal boot sequence. Bug However, the normal boot sequence will not be able to continue, as the next steps to enable the SRAM C block are skipped, so this is expected to fail!","title":"Resume from Standby Mode"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#enable-sram-c","text":"In the next to final step of the start function, the SRAM C (44 KB) is enabled at addresses 0x00004000-0x000efff : first, an undocumented register in System Control block is cleared , that is suspected to enable SRAM C access to the CPU and the DMA Then the Video Engine (VE) is started by enabling its clock and reseting it. It is suspected that the reason it is done here is because the SRAM C block is tied to the Video Engine function","title":"Enable SRAM C"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#initialize-stack-pointer-in-sram-c","text":"In the last step of the start function, the stack pointer is set 4KB below the end of SRAM C (address 0x0000dffc ), before calling the final boot function .","title":"Initialize Stack Pointer in SRAM C"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#boot-function","text":"The role of the boot function is to implement the boot sequence described in the datasheet: Wrong! However, we found out that this diagram is inacurate!","title":"Boot Function"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#check-uboot-button","text":"The first step in the boot function is to check if an \"UBoot button\" is pressed by calling the check_uboot function . Note Here, \"UBoot\" stands for \" USB Boot\", it has nothing to do whith \"Das U-Boot\" bootloader! However, as the check_uboot function uses a special register to check the input pin rather than the standard PIO controller, it is not possible to determine from the code which pin is actually involved. We are not aware of any pin on the V3s that has this capability, although we suspected the PF6 pin (pin 100) to have this function as it has no alternate function like all the other pins, but this is not the case: pulling this pin to GND during the boot process has no effect, so likely, this function is not implemented on the V3s. If this hypothetical button is pressed during the boot sequence, the boot function would branch directly to the FEL USB Boot code, bypassing the normal boot process.","title":"Check UBoot Button"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#boot-from-flash-memory","text":"Unlike what is describe in the control flow diagram above, the V3s search order for the Flash memory to boot from is actually the following: SD Card on SDC0 interface eMMC chip on SDC2 interface SD Card on SDC2 interface NOR Flash chip on SPI interface NAND Flash chip on SPI interface For all Flash memory types, the boot process is similar: read one 512 byte block at address 0x00000000 from the Flash device to get a \" BOOT0 Header \" check the \" eGON.BT0 \" signature at the very beginning of the loaded block using the check_magic function ( example for booting from MMC0 ) check the length field at offset 16: the second stage bootloader length must be < 32KB (0x8000), example for booting from MMC0 check if the length field bits 24:31 are null (which is always true anyway because of the test above, example for booting from MMC0 ) perform 2 attempts to read the required number of 512-byte blocks for the specified length and load them at address 0x00000000 from the Flash device (it looks like the first block is re-read, example for booting from MMC0 ). The reason to perform 2 attempts is unknown eventually, jump to the .boot_spl function , which: loads 0xfc into register r1 and 0x0 into register r0 calls the jump_spl function that: saves the r0 contents to r4 calls in turn the jump_to function that: loads r0 into the program counter and never returns, actually launching the loaded SPL (Secondary Program Loader) at address 0x00000000 in SRAM A1 and C If no bootable Flash memory is found, the boot function will branch to the FEL USB Boot code.","title":"Boot from Flash Memory"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#booting-from-sd-card","text":"As on the FunKey S the only available Flash memory to boot from is the SD Card, we will focus on this one and ignore the other devices. The only SD Card specificity regarding the boot process is that the BOOT0 header above is fetched from 2 byte-offsets from the beginning of the card: at offset 8KB at offset 128KB The reason why these particular offsets were chosen is unknown, but they are not very convenient for card following a standard partitioning scheme: the 8KB offset falls in the middle of the Primary GPT in a GUID Partition Table scheme. As most SD Card are optimized in hardware for the old MBR scheme, it is not critical both offsets fall within the first 1GB on the disk, which is most of the time not allocated for disk partitions, so they require specific tools to access them On the FunKey S , the 8KB offset is used for the SPL , detailed in the next section. The SD Card interface used (0 or 2) is stored into the BOOT0 header in the byte at offset 40, and bit 5 in this byte is set to 1 when the BOOT0 header is loaded from offset 128 KB, and to 0 when booted from offset 8KB by this code .","title":"Booting from SD Card"},{"location":"developer_guide/software_reference/boot_process/boot_rom/#fel","text":"The FEL is a low-level subroutine also contained in the BootROM on Allwinner devices. It is used for initial programming and recovery of devices using USB . The FEL is actually implementing a tiny USB stack for a proprietary USB protocol different from the standard DFU (Device Firmware Update) protocol used by many other devices. Using some specific tools on the host computer, it is possible to read or write data to/from the device over USB and execute code on it, providing a way to boot the system over USB . These \"sunxi-tools\" are described here and here . Warning For the V3s, it is mandatory to build the version from the repository , as the versions packaged in the different operating systems are too old and do not take into account the V3s chip. Using the \"sunxi-tools\" and the built-in FEL mode from the BootROM, it is possible to boot the V3s CPU over USB without any attached Flash storage.","title":"FEL"},{"location":"developer_guide/software_reference/boot_process/bootloader/","text":"","title":"U-Boot Bootloader"},{"location":"developer_guide/software_reference/boot_process/init_scripts/","text":"","title":"System V Init Scripts"},{"location":"developer_guide/software_reference/boot_process/kernel/","text":"","title":"Linux Kernel"},{"location":"developer_guide/software_reference/boot_process/shutdown_process/","text":"","title":"Shutdown Process"},{"location":"developer_guide/software_reference/boot_process/spl/","text":"The SPL is the Secondary Program Loader (the Primary Program Loader being the code in the Boot ROM ), it is the first user-customizable piece of code run on the CPU . The SPL is built as part of the U-Boot bootlader. Actually, it shares most of its code with it. The SPL is loaded by the Boot ROM at address 0x00000000 in SRAM A1 and C, and has a maximum size of 32KB. It contains a \" BOOT0 Header \" that has been checked previously by the Boot ROM , and its byte at offset 40 has been updated with the SD card interface used to boot, with its bit 5 set to 1 if it was loaded from offset 128KB from the SD Card, or 0 if was loaded from offset 8KB. The role of the SPL stage is to set up the CPU clocks to their nominal speeds and set up the main SDRAM memory in order to load into it the next boot stage: either the U-Boot bootloader or the Linux kernel, as these are too large to fit into the small SRAM memory.","title":"SPL"},{"location":"developer_guide/software_reference/sd_card_layout/","text":"","title":"SD-Card Layout"},{"location":"developer_guide/software_reference/sd_card_layout/directory_structure/","text":"As the FunKey-OS is based on Linux, it conforms with a few exceptions to the Filesystem Hierarchy Standard (FHS) . Hierearchies \u00b6 The FHS defines 3 hierarchies of directories: The primary hierarchy is mandatory and contains all required directories and essential binaries, as well as the other hierarchies The secondary hierarchy contains read-only, shareable user data and incldues the majority of user utilities and applications The tertiary hierarchy contains local data specific to a host Directory Description / Primary hierarchy root and root directory of the entire file system hierarchy. /bin Essential command binaries that need to be available in single-user mode, including to bring up the system or repair it, for all users (e.g., cat, ls, cp). /boot Boot loader files: the Linux kernel and its Device Tree blob (configuration file for the Linux kernel). /dev Device files (e.g., /dev/null , /dev/disk0 , /dev/sda1 , /dev/tty , /dev/random ). /etc Host-specific system-wide configuration files. /lib Run-time libraries essential for the binaries in /bin and /sbin . /media Mount points for removable media such as CD-ROMs (appeared in FHS-2.3 in 2004). /mnt Temporarily mounted filesystems. /opt Optional application software packages. /proc Virtual filesystem providing process and kernel information as files. In Linux, corresponds to a procfs mount. Generally, automatically generated and populated by the system, on the fly. /root Home directory for the root user. /run Run-time variable data: Information about the running system since last boot, e.g., currently logged-in users and running daemons. Files under this directory must be either removed or truncated at the beginning of the boot process, but this is not necessary on systems that provide this directory as a temporary filesystem (tmpfs). /sbin Essential system binaries (e.g., fsck, init, route). /sys Contains information about devices, drivers, and some kernel features. /tmp Temporary folder /usr Secondary hierarchy for read-only user data; contains the majority of (multi-)user utilities and applications. Should be shareable and read-only. /usr/bin Non-essential command executable /usr/lib Library (computer science) /usr/local Tertiary hierarchy for local data, specific to this host. Typically has further subdirectories (e.g., bin , lib , share ). /usr/sbin Non-essential system binaries (e.g., Daemon (computer software) /usr/share Architecture-independent (shared) data. /var Variable files: files whose content is expected to continually change during normal operation of the system, such as logs, spool files, etc. /var/cache Application cache data. Such data are locally generated as a result of time-consuming I/O or calculation. The application must be able to regenerate or restore the data. The cached files can be deleted without loss of data. /var/lib State information. Persistent data modified by programs as they run (e.g., databases, packaging system metadata, etc.). /var/lock Lock files. Files keeping track of resources currently in use. /var/log Log files. Various logs. /var/opt Variable data from add-on packages that are stored in /opt . /var/run Run-time variable data. This directory contains system information data describing the system since it was booted. In FHS 3.0, /var/run is replaced by /run ; a system should either continue to provide a /var/run directory or provide a symbolic link from /var/run to /run for backwards compatibility. /var/spool Spool for tasks waiting to be processed (e.g., print queues and outgoing mail queue). /var/tmp Temporary files to be preserved between reboots Directory Description /etc/opt Configuration files for add-on packages that are stored in /opt . /etc/sgml Configuration files, such as catalogs, for software that processes SGML. /etc/X11 Configuration files for the X Window System, version 11. /etc/xml Configuration files, such as catalogs, for software that processes XML. /home Users' home directory /lib<qual> Alternate format essential libraries. These are typically used on systems that support more than one executable code format, such as systems supporting 32-bit and 64-bit versions of an instruction set. Such directories are optional, but if they exist, they have some requirements. /srv Site-specific data served by this system, such as data and scripts for web servers, data offered by FTP servers, and repositories for version control systems (appeared in FHS-2.3 in 2004). /usr/include Standard header file /usr/lib<qual> Alternative-format libraries (e.g., /usr/lib32 for 32-bit libraries on a 64-bit machine (optional)). /usr/src Source code (e.g., the kernel source code with its header files). /usr/X11R6 X Window System, Version 11, Release 6 (up to FHS-2.3, optional). /var/mail Mailbox files. In some distributions, these files may be located in the deprecated /var/spool/mail . /var/spool/mail Deprecated location for users' mailboxes. / \u251c\u2500\u2500 bin \u251c\u2500\u2500 boot \u251c\u2500\u2500 dev \u2502 \u251c\u2500\u2500 pts \u2502 \u2514\u2500\u2500 shm \u251c\u2500\u2500 etc \u2502 \u251c\u2500\u2500 cron.d \u2502 \u251c\u2500\u2500 default \u2502 \u251c\u2500\u2500 dropbear -> /tmp \u2502 \u251c\u2500\u2500 init.d \u2502 \u251c\u2500\u2500 libnl \u2502 \u251c\u2500\u2500 network \u2502 \u2502 \u251c\u2500\u2500 if-down.d \u2502 \u2502 \u251c\u2500\u2500 if-post-down.d \u2502 \u2502 \u251c\u2500\u2500 if-pre-up.d \u2502 \u2502 \u251c\u2500\u2500 if-up.d \u2502 \u2502 \u2514\u2500\u2500 interfaces.d \u2502 \u251c\u2500\u2500 profile.d \u2502 \u2514\u2500\u2500 sysconfig \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dhcpcd \u2502 \u2502 \u2514\u2500\u2500 dhcpcd-hooks \u2502 \u251c\u2500\u2500 lsb \u2502 \u2514\u2500\u2500 modules \u2502 \u2514\u2500\u2500 4.14.14-funkey \u2502 \u2514\u2500\u2500 kernel \u2502 \u251c\u2500\u2500 crypto \u2502 \u2514\u2500\u2500 drivers \u2502 \u251c\u2500\u2500 usb \u2502 \u2502 \u2514\u2500\u2500 gadget \u2502 \u2502 \u251c\u2500\u2500 function \u2502 \u2502 \u2514\u2500\u2500 legacy \u2502 \u2514\u2500\u2500 video \u2502 \u2514\u2500\u2500 backlight \u251c\u2500\u2500 lib32 -> lib \u251c\u2500\u2500 media -> /mnt \u251c\u2500\u2500 mnt \u2502 \u251c\u2500\u2500 Applications \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u251c\u2500\u2500 Emulators \u2502 \u251c\u2500\u2500 FunKey \u2502 \u2502 \u251c\u2500\u2500 .gmenu2x \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 applications \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 emulators \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 games \u2502 \u2502 \u2502 \u2514\u2500\u2500 skins \u2502 \u2502 \u2502 \u2514\u2500\u2500 240x240 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2514\u2500\u2500 ScanlinesBlue \u2502 \u2502 \u251c\u2500\u2500 Launchers \u2502 \u2502 \u251c\u2500\u2500 .mednafen \u2502 \u2502 \u251c\u2500\u2500 .pcsx \u2502 \u2502 \u251c\u2500\u2500 .sm64-port \u2502 \u2502 \u2514\u2500\u2500 snapshots \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u251c\u2500\u2500 Games \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u251c\u2500\u2500 NES \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u251c\u2500\u2500 bios \u2502 \u2502 \u2514\u2500\u2500 memcards \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u251c\u2500\u2500 SNES \u2502 \u251c\u2500\u2500 System Volume Information \u2502 \u2514\u2500\u2500 WonderSwan \u251c\u2500\u2500 opk \u251c\u2500\u2500 opt \u251c\u2500\u2500 proc \u251c\u2500\u2500 root \u251c\u2500\u2500 run \u251c\u2500\u2500 sbin \u251c\u2500\u2500 sys \u251c\u2500\u2500 tmp \u2502 \u2514\u2500\u2500 sa \u251c\u2500\u2500 usr \u2502 \u251c\u2500\u2500 bin \u2502 \u251c\u2500\u2500 games \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Main \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u251c\u2500\u2500 core \u2502 \u2502 \u251c\u2500\u2500 launchers \u2502 \u2502 \u251c\u2500\u2500 layouts \u2502 \u2502 \u2502 \u251c\u2500\u2500 Classic \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sounds \u2502 \u2502 \u2502 \u251c\u2500\u2500 Flat \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sounds \u2502 \u2502 \u2502 \u251c\u2500\u2500 FunKey \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sounds \u2502 \u2502 \u2502 \u2514\u2500\u2500 TFT \u2502 \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u2514\u2500\u2500 sounds \u2502 \u2502 \u251c\u2500\u2500 menu_resources \u2502 \u2502 \u2514\u2500\u2500 opk \u2502 \u251c\u2500\u2500 lib \u2502 \u2502 \u251c\u2500\u2500 e2fsprogs \u2502 \u2502 \u251c\u2500\u2500 gstreamer-1.0 \u2502 \u2502 \u251c\u2500\u2500 icu \u2502 \u2502 \u2502 \u251c\u2500\u2500 67.1 \u2502 \u2502 \u2502 \u2514\u2500\u2500 current -> 67.1 \u2502 \u2502 \u251c\u2500\u2500 lua \u2502 \u2502 \u2502 \u2514\u2500\u2500 5.3 \u2502 \u2502 \u251c\u2500\u2500 mpg123 \u2502 \u2502 \u251c\u2500\u2500 sa \u2502 \u2502 \u2514\u2500\u2500 terminfo -> ../share/terminfo \u2502 \u251c\u2500\u2500 lib32 -> lib \u2502 \u251c\u2500\u2500 libexec \u2502 \u2502 \u2514\u2500\u2500 gstreamer-1.0 \u2502 \u251c\u2500\u2500 local \u2502 \u2502 \u251c\u2500\u2500 lib \u2502 \u2502 \u251c\u2500\u2500 sbin \u2502 \u2502 \u2514\u2500\u2500 share \u2502 \u2502 \u2514\u2500\u2500 ProdResources \u2502 \u251c\u2500\u2500 sbin \u2502 \u2514\u2500\u2500 share \u2502 \u251c\u2500\u2500 alsa \u2502 \u2502 \u251c\u2500\u2500 cards \u2502 \u2502 \u251c\u2500\u2500 init \u2502 \u2502 \u251c\u2500\u2500 pcm \u2502 \u2502 \u2514\u2500\u2500 speaker-test \u2502 \u251c\u2500\u2500 aumix \u2502 \u251c\u2500\u2500 dhcpcd \u2502 \u2502 \u2514\u2500\u2500 hooks \u2502 \u251c\u2500\u2500 et \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u251c\u2500\u2500 dejavu \u2502 \u2502 \u251c\u2500\u2500 droid \u2502 \u2502 \u2514\u2500\u2500 truetype -> . \u2502 \u251c\u2500\u2500 gettext \u2502 \u2502 \u2514\u2500\u2500 its \u2502 \u251c\u2500\u2500 glib-2.0 \u2502 \u2502 \u251c\u2500\u2500 schemas \u2502 \u2502 \u2514\u2500\u2500 valgrind \u2502 \u251c\u2500\u2500 gmenu2x \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2514\u2500\u2500 games \u2502 \u2502 \u251c\u2500\u2500 skins \u2502 \u2502 \u2502 \u251c\u2500\u2500 1280x720 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons -> ../../320x240/Default/icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs -> ../../320x240/Default/imgs \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections -> ../../320x240/Default/sections \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u251c\u2500\u2500 240x160 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons -> ../../320x240/Default/icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs -> ../../320x240/Default/imgs \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections -> ../../320x240/Default/sections \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u251c\u2500\u2500 240x240 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 GCW \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 ScanlinesBlue \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 ScanlinesRed \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u251c\u2500\u2500 320x240 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 GCW \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 ScanlinesBlue \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 ScanlinesRed \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u251c\u2500\u2500 640x480 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons -> ../../320x240/Default/icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs -> ../../320x240/Default/imgs \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sections -> ../../320x240/Default/sections \u2502 \u2502 \u2502 \u2514\u2500\u2500 800x480 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Default \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons -> ../../320x240/Default/icons \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs -> ../../320x240/Default/imgs \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections -> ../../320x240/Default/sections \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2514\u2500\u2500 translations \u2502 \u251c\u2500\u2500 gst-plugins-base \u2502 \u2502 \u2514\u2500\u2500 1.0 \u2502 \u251c\u2500\u2500 gstreamer-1.0 \u2502 \u2502 \u2514\u2500\u2500 gdb \u2502 \u251c\u2500\u2500 locale \u2502 \u251c\u2500\u2500 lua \u2502 \u2502 \u2514\u2500\u2500 5.3 \u2502 \u251c\u2500\u2500 mime \u2502 \u251c\u2500\u2500 sounds \u2502 \u2502 \u2514\u2500\u2500 alsa \u2502 \u251c\u2500\u2500 ss \u2502 \u251c\u2500\u2500 terminfo \u2502 \u2502 \u251c\u2500\u2500 a \u2502 \u2502 \u251c\u2500\u2500 d \u2502 \u2502 \u251c\u2500\u2500 l \u2502 \u2502 \u251c\u2500\u2500 p \u2502 \u2502 \u251c\u2500\u2500 s \u2502 \u2502 \u251c\u2500\u2500 v \u2502 \u2502 \u2514\u2500\u2500 x \u2502 \u2514\u2500\u2500 udhcpc \u2502 \u2514\u2500\u2500 default.script.d \u2514\u2500\u2500 var \u251c\u2500\u2500 cache -> ../tmp \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 alsa \u2502 \u251c\u2500\u2500 dhcp -> /tmp \u2502 \u2514\u2500\u2500 misc -> ../../tmp \u251c\u2500\u2500 lock -> ../tmp \u251c\u2500\u2500 log -> ../tmp \u251c\u2500\u2500 run -> ../run \u251c\u2500\u2500 spool -> ../tmp \u2514\u2500\u2500 tmp -> ../tmp","title":"Directory structure"},{"location":"developer_guide/software_reference/sd_card_layout/directory_structure/#hierearchies","text":"The FHS defines 3 hierarchies of directories: The primary hierarchy is mandatory and contains all required directories and essential binaries, as well as the other hierarchies The secondary hierarchy contains read-only, shareable user data and incldues the majority of user utilities and applications The tertiary hierarchy contains local data specific to a host Directory Description / Primary hierarchy root and root directory of the entire file system hierarchy. /bin Essential command binaries that need to be available in single-user mode, including to bring up the system or repair it, for all users (e.g., cat, ls, cp). /boot Boot loader files: the Linux kernel and its Device Tree blob (configuration file for the Linux kernel). /dev Device files (e.g., /dev/null , /dev/disk0 , /dev/sda1 , /dev/tty , /dev/random ). /etc Host-specific system-wide configuration files. /lib Run-time libraries essential for the binaries in /bin and /sbin . /media Mount points for removable media such as CD-ROMs (appeared in FHS-2.3 in 2004). /mnt Temporarily mounted filesystems. /opt Optional application software packages. /proc Virtual filesystem providing process and kernel information as files. In Linux, corresponds to a procfs mount. Generally, automatically generated and populated by the system, on the fly. /root Home directory for the root user. /run Run-time variable data: Information about the running system since last boot, e.g., currently logged-in users and running daemons. Files under this directory must be either removed or truncated at the beginning of the boot process, but this is not necessary on systems that provide this directory as a temporary filesystem (tmpfs). /sbin Essential system binaries (e.g., fsck, init, route). /sys Contains information about devices, drivers, and some kernel features. /tmp Temporary folder /usr Secondary hierarchy for read-only user data; contains the majority of (multi-)user utilities and applications. Should be shareable and read-only. /usr/bin Non-essential command executable /usr/lib Library (computer science) /usr/local Tertiary hierarchy for local data, specific to this host. Typically has further subdirectories (e.g., bin , lib , share ). /usr/sbin Non-essential system binaries (e.g., Daemon (computer software) /usr/share Architecture-independent (shared) data. /var Variable files: files whose content is expected to continually change during normal operation of the system, such as logs, spool files, etc. /var/cache Application cache data. Such data are locally generated as a result of time-consuming I/O or calculation. The application must be able to regenerate or restore the data. The cached files can be deleted without loss of data. /var/lib State information. Persistent data modified by programs as they run (e.g., databases, packaging system metadata, etc.). /var/lock Lock files. Files keeping track of resources currently in use. /var/log Log files. Various logs. /var/opt Variable data from add-on packages that are stored in /opt . /var/run Run-time variable data. This directory contains system information data describing the system since it was booted. In FHS 3.0, /var/run is replaced by /run ; a system should either continue to provide a /var/run directory or provide a symbolic link from /var/run to /run for backwards compatibility. /var/spool Spool for tasks waiting to be processed (e.g., print queues and outgoing mail queue). /var/tmp Temporary files to be preserved between reboots Directory Description /etc/opt Configuration files for add-on packages that are stored in /opt . /etc/sgml Configuration files, such as catalogs, for software that processes SGML. /etc/X11 Configuration files for the X Window System, version 11. /etc/xml Configuration files, such as catalogs, for software that processes XML. /home Users' home directory /lib<qual> Alternate format essential libraries. These are typically used on systems that support more than one executable code format, such as systems supporting 32-bit and 64-bit versions of an instruction set. Such directories are optional, but if they exist, they have some requirements. /srv Site-specific data served by this system, such as data and scripts for web servers, data offered by FTP servers, and repositories for version control systems (appeared in FHS-2.3 in 2004). /usr/include Standard header file /usr/lib<qual> Alternative-format libraries (e.g., /usr/lib32 for 32-bit libraries on a 64-bit machine (optional)). /usr/src Source code (e.g., the kernel source code with its header files). /usr/X11R6 X Window System, Version 11, Release 6 (up to FHS-2.3, optional). /var/mail Mailbox files. In some distributions, these files may be located in the deprecated /var/spool/mail . /var/spool/mail Deprecated location for users' mailboxes. / \u251c\u2500\u2500 bin \u251c\u2500\u2500 boot \u251c\u2500\u2500 dev \u2502 \u251c\u2500\u2500 pts \u2502 \u2514\u2500\u2500 shm \u251c\u2500\u2500 etc \u2502 \u251c\u2500\u2500 cron.d \u2502 \u251c\u2500\u2500 default \u2502 \u251c\u2500\u2500 dropbear -> /tmp \u2502 \u251c\u2500\u2500 init.d \u2502 \u251c\u2500\u2500 libnl \u2502 \u251c\u2500\u2500 network \u2502 \u2502 \u251c\u2500\u2500 if-down.d \u2502 \u2502 \u251c\u2500\u2500 if-post-down.d \u2502 \u2502 \u251c\u2500\u2500 if-pre-up.d \u2502 \u2502 \u251c\u2500\u2500 if-up.d \u2502 \u2502 \u2514\u2500\u2500 interfaces.d \u2502 \u251c\u2500\u2500 profile.d \u2502 \u2514\u2500\u2500 sysconfig \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dhcpcd \u2502 \u2502 \u2514\u2500\u2500 dhcpcd-hooks \u2502 \u251c\u2500\u2500 lsb \u2502 \u2514\u2500\u2500 modules \u2502 \u2514\u2500\u2500 4.14.14-funkey \u2502 \u2514\u2500\u2500 kernel \u2502 \u251c\u2500\u2500 crypto \u2502 \u2514\u2500\u2500 drivers \u2502 \u251c\u2500\u2500 usb \u2502 \u2502 \u2514\u2500\u2500 gadget \u2502 \u2502 \u251c\u2500\u2500 function \u2502 \u2502 \u2514\u2500\u2500 legacy \u2502 \u2514\u2500\u2500 video \u2502 \u2514\u2500\u2500 backlight \u251c\u2500\u2500 lib32 -> lib \u251c\u2500\u2500 media -> /mnt \u251c\u2500\u2500 mnt \u2502 \u251c\u2500\u2500 Applications \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u251c\u2500\u2500 Emulators \u2502 \u251c\u2500\u2500 FunKey \u2502 \u2502 \u251c\u2500\u2500 .gmenu2x \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 applications \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 emulators \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 games \u2502 \u2502 \u2502 \u2514\u2500\u2500 skins \u2502 \u2502 \u2502 \u2514\u2500\u2500 240x240 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2514\u2500\u2500 ScanlinesBlue \u2502 \u2502 \u251c\u2500\u2500 Launchers \u2502 \u2502 \u251c\u2500\u2500 .mednafen \u2502 \u2502 \u251c\u2500\u2500 .pcsx \u2502 \u2502 \u251c\u2500\u2500 .sm64-port \u2502 \u2502 \u2514\u2500\u2500 snapshots \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u251c\u2500\u2500 Games \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u251c\u2500\u2500 NES \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u251c\u2500\u2500 bios \u2502 \u2502 \u2514\u2500\u2500 memcards \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u251c\u2500\u2500 SNES \u2502 \u251c\u2500\u2500 System Volume Information \u2502 \u2514\u2500\u2500 WonderSwan \u251c\u2500\u2500 opk \u251c\u2500\u2500 opt \u251c\u2500\u2500 proc \u251c\u2500\u2500 root \u251c\u2500\u2500 run \u251c\u2500\u2500 sbin \u251c\u2500\u2500 sys \u251c\u2500\u2500 tmp \u2502 \u2514\u2500\u2500 sa \u251c\u2500\u2500 usr \u2502 \u251c\u2500\u2500 bin \u2502 \u251c\u2500\u2500 games \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Main \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u251c\u2500\u2500 core \u2502 \u2502 \u251c\u2500\u2500 launchers \u2502 \u2502 \u251c\u2500\u2500 layouts \u2502 \u2502 \u2502 \u251c\u2500\u2500 Classic \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sounds \u2502 \u2502 \u2502 \u251c\u2500\u2500 Flat \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sounds \u2502 \u2502 \u2502 \u251c\u2500\u2500 FunKey \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sounds \u2502 \u2502 \u2502 \u2514\u2500\u2500 TFT \u2502 \u2502 \u2502 \u251c\u2500\u2500 collections \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Atari lynx \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Advance \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Boy Color \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Game Gear \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Neo Geo Pocket \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 NES \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PCE-TurboGrafx \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 PS1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Genesis \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Sega Master System \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 SNES \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 WonderSwan \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 system_artwork \u2502 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u2514\u2500\u2500 sounds \u2502 \u2502 \u251c\u2500\u2500 menu_resources \u2502 \u2502 \u2514\u2500\u2500 opk \u2502 \u251c\u2500\u2500 lib \u2502 \u2502 \u251c\u2500\u2500 e2fsprogs \u2502 \u2502 \u251c\u2500\u2500 gstreamer-1.0 \u2502 \u2502 \u251c\u2500\u2500 icu \u2502 \u2502 \u2502 \u251c\u2500\u2500 67.1 \u2502 \u2502 \u2502 \u2514\u2500\u2500 current -> 67.1 \u2502 \u2502 \u251c\u2500\u2500 lua \u2502 \u2502 \u2502 \u2514\u2500\u2500 5.3 \u2502 \u2502 \u251c\u2500\u2500 mpg123 \u2502 \u2502 \u251c\u2500\u2500 sa \u2502 \u2502 \u2514\u2500\u2500 terminfo -> ../share/terminfo \u2502 \u251c\u2500\u2500 lib32 -> lib \u2502 \u251c\u2500\u2500 libexec \u2502 \u2502 \u2514\u2500\u2500 gstreamer-1.0 \u2502 \u251c\u2500\u2500 local \u2502 \u2502 \u251c\u2500\u2500 lib \u2502 \u2502 \u251c\u2500\u2500 sbin \u2502 \u2502 \u2514\u2500\u2500 share \u2502 \u2502 \u2514\u2500\u2500 ProdResources \u2502 \u251c\u2500\u2500 sbin \u2502 \u2514\u2500\u2500 share \u2502 \u251c\u2500\u2500 alsa \u2502 \u2502 \u251c\u2500\u2500 cards \u2502 \u2502 \u251c\u2500\u2500 init \u2502 \u2502 \u251c\u2500\u2500 pcm \u2502 \u2502 \u2514\u2500\u2500 speaker-test \u2502 \u251c\u2500\u2500 aumix \u2502 \u251c\u2500\u2500 dhcpcd \u2502 \u2502 \u2514\u2500\u2500 hooks \u2502 \u251c\u2500\u2500 et \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u251c\u2500\u2500 dejavu \u2502 \u2502 \u251c\u2500\u2500 droid \u2502 \u2502 \u2514\u2500\u2500 truetype -> . \u2502 \u251c\u2500\u2500 gettext \u2502 \u2502 \u2514\u2500\u2500 its \u2502 \u251c\u2500\u2500 glib-2.0 \u2502 \u2502 \u251c\u2500\u2500 schemas \u2502 \u2502 \u2514\u2500\u2500 valgrind \u2502 \u251c\u2500\u2500 gmenu2x \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2514\u2500\u2500 games \u2502 \u2502 \u251c\u2500\u2500 skins \u2502 \u2502 \u2502 \u251c\u2500\u2500 1280x720 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons -> ../../320x240/Default/icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs -> ../../320x240/Default/imgs \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections -> ../../320x240/Default/sections \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u251c\u2500\u2500 240x160 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons -> ../../320x240/Default/icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs -> ../../320x240/Default/imgs \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections -> ../../320x240/Default/sections \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u251c\u2500\u2500 240x240 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 GCW \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 ScanlinesBlue \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 ScanlinesRed \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u251c\u2500\u2500 320x240 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 GCW \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 ScanlinesBlue \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 ScanlinesRed \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 fonts \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 battery \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 buttons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2502 \u251c\u2500\u2500 640x480 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Default \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons -> ../../320x240/Default/icons \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs -> ../../320x240/Default/imgs \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sections -> ../../320x240/Default/sections \u2502 \u2502 \u2502 \u2514\u2500\u2500 800x480 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Default \u2502 \u2502 \u2502 \u251c\u2500\u2500 icons -> ../../320x240/Default/icons \u2502 \u2502 \u2502 \u251c\u2500\u2500 imgs -> ../../320x240/Default/imgs \u2502 \u2502 \u2502 \u251c\u2500\u2500 sections -> ../../320x240/Default/sections \u2502 \u2502 \u2502 \u2514\u2500\u2500 wallpapers \u2502 \u2502 \u2514\u2500\u2500 translations \u2502 \u251c\u2500\u2500 gst-plugins-base \u2502 \u2502 \u2514\u2500\u2500 1.0 \u2502 \u251c\u2500\u2500 gstreamer-1.0 \u2502 \u2502 \u2514\u2500\u2500 gdb \u2502 \u251c\u2500\u2500 locale \u2502 \u251c\u2500\u2500 lua \u2502 \u2502 \u2514\u2500\u2500 5.3 \u2502 \u251c\u2500\u2500 mime \u2502 \u251c\u2500\u2500 sounds \u2502 \u2502 \u2514\u2500\u2500 alsa \u2502 \u251c\u2500\u2500 ss \u2502 \u251c\u2500\u2500 terminfo \u2502 \u2502 \u251c\u2500\u2500 a \u2502 \u2502 \u251c\u2500\u2500 d \u2502 \u2502 \u251c\u2500\u2500 l \u2502 \u2502 \u251c\u2500\u2500 p \u2502 \u2502 \u251c\u2500\u2500 s \u2502 \u2502 \u251c\u2500\u2500 v \u2502 \u2502 \u2514\u2500\u2500 x \u2502 \u2514\u2500\u2500 udhcpc \u2502 \u2514\u2500\u2500 default.script.d \u2514\u2500\u2500 var \u251c\u2500\u2500 cache -> ../tmp \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 alsa \u2502 \u251c\u2500\u2500 dhcp -> /tmp \u2502 \u2514\u2500\u2500 misc -> ../../tmp \u251c\u2500\u2500 lock -> ../tmp \u251c\u2500\u2500 log -> ../tmp \u251c\u2500\u2500 run -> ../run \u251c\u2500\u2500 spool -> ../tmp \u2514\u2500\u2500 tmp -> ../tmp","title":"Hierearchies"},{"location":"developer_guide/software_reference/sd_card_layout/partition_map/","text":"","title":"Partition Map"},{"location":"developer_guide/software_reference/sd_card_layout/recovery_partition/","text":"","title":"Recovery Partition"},{"location":"developer_guide/software_reference/sd_card_layout/root_filesystem_partition/","text":"","title":"Root Filesystem Partition"},{"location":"developer_guide/software_reference/sd_card_layout/usb_shared_partition/","text":"","title":"USB Shared Partition"},{"location":"developer_guide/tutorials/access_recovery/","text":"The Recovery Mode is a special boot mode that can be entered when booting the FunKey S console. Its main purpose is to handle system updates, but it can also be used to recover the main system when it is no longer accessible, or to access some advanced test or developement features. Enter the Recovery Mode \u00b6 There are 2 different ways to enter Recovery Mode: by holding both the and the keys at the same time while booting the FunKey S console by typing the following command at the Shell prompt, either using ssh over USB Ethernet or the serial console: $ recovery_mode While booting, the system will display the following logo instead of the familiar FunKey S logo: Recovery mode commands \u00b6 The Recovery Mode automatically enables the USB network client upon startup, allowing ssh connection over the USB cable for debug purposes. For more information, please check the SSH Connection over USB section . At the same time, the Recovery mode provides a simple text menu, with the current menu item displayed at the top of the screen. Navigation through the menu commands is using the and keys, and validation is using the key. INFO \u00b6 This command displays useful information regarding the FunKey S : the Recovery Mode version the rootfs (e.g. \"Normal\" Mode) version if connected to a host through USB network, the device IP address Recovery: 2.0.0 rootfs : 2.0.0 IP addr : 192.168.137.20 USB MOUNT/UNMOUNT \u00b6 This toggle commands performs the same way as the FunKey menu command, except that no confirmation is asked. USB CHECK \u00b6 This command performs a check of the FAT32 USB partition, and try to repair it if it finds some errors, such as when the partition was not cleanly unmounted from a host computer. USB FORMAT \u00b6 This commands formats the FAT32 USB partition. Warning This function will delete all the files on the USB partition, so be careful! NETWORK ENABLE/DISABLE \u00b6 This toggle command will enable/disable the USB network upon next boot. QR CODE \u00b6 This command will display a full screen QR Code containing the FunKey S serial number: FACTORY TEST ENABLE/DISABLE \u00b6 This toggle command will enable/disable the factory tests upon next boot. FIRST BOOT ENABLE/DISABLE \u00b6 This toggle command will enable/disable the \"first boot\" sequence that: expands the rootfs \"Normal\" system partition create the swap partition create the USB shared partition install the free built-in games EXIT RECOVERY \u00b6 This comand exits the Recovery Mode and reboots in Normal Mode.","title":"Access the Recovery Boot Mode"},{"location":"developer_guide/tutorials/access_recovery/#enter-the-recovery-mode","text":"There are 2 different ways to enter Recovery Mode: by holding both the and the keys at the same time while booting the FunKey S console by typing the following command at the Shell prompt, either using ssh over USB Ethernet or the serial console: $ recovery_mode While booting, the system will display the following logo instead of the familiar FunKey S logo:","title":"Enter the Recovery Mode"},{"location":"developer_guide/tutorials/access_recovery/#recovery-mode-commands","text":"The Recovery Mode automatically enables the USB network client upon startup, allowing ssh connection over the USB cable for debug purposes. For more information, please check the SSH Connection over USB section . At the same time, the Recovery mode provides a simple text menu, with the current menu item displayed at the top of the screen. Navigation through the menu commands is using the and keys, and validation is using the key.","title":"Recovery mode commands"},{"location":"developer_guide/tutorials/access_recovery/#info","text":"This command displays useful information regarding the FunKey S : the Recovery Mode version the rootfs (e.g. \"Normal\" Mode) version if connected to a host through USB network, the device IP address Recovery: 2.0.0 rootfs : 2.0.0 IP addr : 192.168.137.20","title":"INFO"},{"location":"developer_guide/tutorials/access_recovery/#usb-mountunmount","text":"This toggle commands performs the same way as the FunKey menu command, except that no confirmation is asked.","title":"USB MOUNT/UNMOUNT"},{"location":"developer_guide/tutorials/access_recovery/#usb-check","text":"This command performs a check of the FAT32 USB partition, and try to repair it if it finds some errors, such as when the partition was not cleanly unmounted from a host computer.","title":"USB CHECK"},{"location":"developer_guide/tutorials/access_recovery/#usb-format","text":"This commands formats the FAT32 USB partition. Warning This function will delete all the files on the USB partition, so be careful!","title":"USB FORMAT"},{"location":"developer_guide/tutorials/access_recovery/#network-enabledisable","text":"This toggle command will enable/disable the USB network upon next boot.","title":"NETWORK ENABLE/DISABLE"},{"location":"developer_guide/tutorials/access_recovery/#qr-code","text":"This command will display a full screen QR Code containing the FunKey S serial number:","title":"QR CODE"},{"location":"developer_guide/tutorials/access_recovery/#factory-test-enabledisable","text":"This toggle command will enable/disable the factory tests upon next boot.","title":"FACTORY TEST ENABLE/DISABLE"},{"location":"developer_guide/tutorials/access_recovery/#first-boot-enabledisable","text":"This toggle command will enable/disable the \"first boot\" sequence that: expands the rootfs \"Normal\" system partition create the swap partition create the USB shared partition install the free built-in games","title":"FIRST BOOT ENABLE/DISABLE"},{"location":"developer_guide/tutorials/access_recovery/#exit-recovery","text":"This comand exits the Recovery Mode and reboots in Normal Mode.","title":"EXIT RECOVERY"},{"location":"developer_guide/tutorials/ssh_connection/","text":"","title":"SSH Connection over USB"},{"location":"developer_guide/tutorials/uart_connection/","text":"","title":"Serial Connection over UART"},{"location":"developer_guide/tutorials/build_system/","text":"The FunKey-S console is based on a sophisticated Allwinner V3s ARM Cortex-A7 1.2GHz CPU , an Operating System is mandatory in order to access all the hardware resources without re-inventing the wheel. Programs made for other computers will not work on the FunKey S , and developing programs on the FunKey S itself is rather impractical (too slow, not enough RAM , etc.). Instead, development for embedded devices like the FunKey S uses a method known as cross compilation for building software on a host platform (such as a desktop computer) to be used on another target platform (like the FunKey S ). The FunKey-OS repository on Github contains all the sources required to build the Open-Source firmware at the heart of the FunKey S retro-gaming console . This repository also contains a standalone SDK, which is a cross-compilation environment based on the GNU GCC compiler and binutils binary object tools, including the compiler toolchain and all the required libraries available on the FunKey S in order to build software for it. FunKey-OS is based on Linux, and is built from scratch using the buildroot tool that simplifies and automates the process of building a complete Linux system for an embedded system like this. Technically speaking, Funkey-OS is a buildroot (v2) based external tree for building the bootloader, the Linux kernel and user utilities, as well as the optimized retro-game launchers and console emulators. For detailed explanations on how to use buildroot itself, please refer to the Buildroot Manual .","title":"Build System"},{"location":"developer_guide/tutorials/build_system/build_program_using_sdk/","text":"This page will guide you through building a very simple application for FunKey using the SDK. FunKey is an embedded Linux device with an ARM processor at its core. Programs made for other computers will not work on FunKey, and developing programs on the FunKey itself is rather impractical. Instead, development for embedded devices like FunKey almost always uses a method known as cross compilation: building software on one platform (such as a desktop computer) to be used on another (like FunKey). The FunKey-SDK contains a cross-compilation environment based on GCC, including the compiler toolchain and the libraries available on the FunKey. Before we can begin, setup a Linux-based compilation environment as shown on this page . Installing the FunKey-SDK \u00b6 The FunKey-SDK is included in releases of the FunKey-OS, starting from version 2.0.0, and can be found on GitHub . Alternatively, you can compile the SDK yourself . Unpack the SDK's .tar.gz file somewhere on your build system. Before you can use the SDK you must first run the relocate-sdk.sh script. This will update all references paths in the SDK to its current location. If you decide to move the SDK to another directory at a later point, don't forget to re-run the script. The SDK is now ready to use. For additional convenience it is highly recommended to source the environment-setup of the SDK. This will add the SDK utilities to the PATH , setup standard variables such as CC and LD to refer to the SDK versions of the toolchain, setup standard options for CFLAGS , and create aliases for configure and cmake to work with the SDK. Your first application \u00b6 Building \u00b6 Let's build a simple application to test that everything is working. Below is a small C program that will use SDL to display a green square for 5 seconds, and then exits. #include <SDL/SDL.h> int main ( int argc , char * argv []) { // Init SDL Video SDL_Init ( SDL_INIT_VIDEO ); // Open HW screen and set video mode 240x240, with double buffering SDL_Surface * hw_surface = SDL_SetVideoMode ( 240 , 240 , 32 , SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_FULLSCREEN ); // Hide the cursor, FunKey doesn't come with a mouse SDL_ShowCursor ( 0 ); // Draw a green square in the middle of the screen SDL_Rect draw_rect = {. x = 70 , . y = 70 , . w = 100 , . h = 100 }; Uint32 color = SDL_MapRGB ( hw_surface -> format , 0 , 255 , 0 ); SDL_FillRect ( hw_surface , & draw_rect , color ); // Switch buffers to show the square we just drew SDL_Flip ( hw_surface ); // Sleep for 5 seconds SDL_Delay ( 5000 ); /// Deinit SDL SDL_Quit (); return 0 ; } Save this file as hello.c somewhere outside of the SDK directory. If you've sourced the environment-setup you can use the variable CC to refer to the C compiler in the SDK. Let's build our program as hello : $CC hello.c -o hello -lSDL Packing \u00b6 The hello program you've just created is a valid executable for FunKey, but in order for the launcher to find it we must first bundle the program in an OPK package. Create a new folder for the contents of the package and put into it: The hello program. An icon for your program in PNG format, 32 x 32 pixels in size, called hello.png . A desktop file called hello.funkey-s.desktop , containing the following text: [Desktop Entry] Type = Application Name = Hello Comment = A simple test app Exec = hello Icon = hello Terminal = false Categories = applications; This file describes your program to the launcher : Type : Always set to \"Application\" Name : This is the name of the application shown in the launcher Comment : A description of the application Exec : This the command to execute your program Icon : The name of the icon file, without the .png extension Terminal : Always set to false, FunKey doesn't support terminal applications Categories : The categories under which the launcher will show the application, in a semicolon-separated list Once you've got everything ready you can turn the folder into a package using the OpenPackage Creator . Select your folder with the Open button, or drag it over the window. The OpenPackage Creator will note that you've already created .desktop file. Choose the \"Use existing as is\" option. Finally, click the Pack button to create hello.opk , ready to be transferred to the FunKey. Installing \u00b6 Connect the FunKey to your computer via USB . Open the menu on the FunKey, select Mount USB and press A twice to confirm. Your FunKey will now be visible as a USB drive on your computer. You can place your application in any 1 st -level folder, and you can create as many as you want to organise your applications. Let's create a new folder called Applications and place hello.opk in there. Safely remove the USB drive from your computer, and in the FunKey menu select Eject USB and press A twice to confirm. Your application is now installed on FunKey. Note that only the GMENU2X launcher can open custom applications . So switch to that launcher via the FunKey menu if you haven't already. You should find an application called Hello under the applications category in the launcher.","title":"Build Programs using SDK"},{"location":"developer_guide/tutorials/build_system/build_program_using_sdk/#installing-the-funkey-sdk","text":"The FunKey-SDK is included in releases of the FunKey-OS, starting from version 2.0.0, and can be found on GitHub . Alternatively, you can compile the SDK yourself . Unpack the SDK's .tar.gz file somewhere on your build system. Before you can use the SDK you must first run the relocate-sdk.sh script. This will update all references paths in the SDK to its current location. If you decide to move the SDK to another directory at a later point, don't forget to re-run the script. The SDK is now ready to use. For additional convenience it is highly recommended to source the environment-setup of the SDK. This will add the SDK utilities to the PATH , setup standard variables such as CC and LD to refer to the SDK versions of the toolchain, setup standard options for CFLAGS , and create aliases for configure and cmake to work with the SDK.","title":"Installing the FunKey-SDK"},{"location":"developer_guide/tutorials/build_system/build_program_using_sdk/#your-first-application","text":"","title":"Your first application"},{"location":"developer_guide/tutorials/build_system/build_program_using_sdk/#building","text":"Let's build a simple application to test that everything is working. Below is a small C program that will use SDL to display a green square for 5 seconds, and then exits. #include <SDL/SDL.h> int main ( int argc , char * argv []) { // Init SDL Video SDL_Init ( SDL_INIT_VIDEO ); // Open HW screen and set video mode 240x240, with double buffering SDL_Surface * hw_surface = SDL_SetVideoMode ( 240 , 240 , 32 , SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_FULLSCREEN ); // Hide the cursor, FunKey doesn't come with a mouse SDL_ShowCursor ( 0 ); // Draw a green square in the middle of the screen SDL_Rect draw_rect = {. x = 70 , . y = 70 , . w = 100 , . h = 100 }; Uint32 color = SDL_MapRGB ( hw_surface -> format , 0 , 255 , 0 ); SDL_FillRect ( hw_surface , & draw_rect , color ); // Switch buffers to show the square we just drew SDL_Flip ( hw_surface ); // Sleep for 5 seconds SDL_Delay ( 5000 ); /// Deinit SDL SDL_Quit (); return 0 ; } Save this file as hello.c somewhere outside of the SDK directory. If you've sourced the environment-setup you can use the variable CC to refer to the C compiler in the SDK. Let's build our program as hello : $CC hello.c -o hello -lSDL","title":"Building"},{"location":"developer_guide/tutorials/build_system/build_program_using_sdk/#packing","text":"The hello program you've just created is a valid executable for FunKey, but in order for the launcher to find it we must first bundle the program in an OPK package. Create a new folder for the contents of the package and put into it: The hello program. An icon for your program in PNG format, 32 x 32 pixels in size, called hello.png . A desktop file called hello.funkey-s.desktop , containing the following text: [Desktop Entry] Type = Application Name = Hello Comment = A simple test app Exec = hello Icon = hello Terminal = false Categories = applications; This file describes your program to the launcher : Type : Always set to \"Application\" Name : This is the name of the application shown in the launcher Comment : A description of the application Exec : This the command to execute your program Icon : The name of the icon file, without the .png extension Terminal : Always set to false, FunKey doesn't support terminal applications Categories : The categories under which the launcher will show the application, in a semicolon-separated list Once you've got everything ready you can turn the folder into a package using the OpenPackage Creator . Select your folder with the Open button, or drag it over the window. The OpenPackage Creator will note that you've already created .desktop file. Choose the \"Use existing as is\" option. Finally, click the Pack button to create hello.opk , ready to be transferred to the FunKey.","title":"Packing"},{"location":"developer_guide/tutorials/build_system/build_program_using_sdk/#installing","text":"Connect the FunKey to your computer via USB . Open the menu on the FunKey, select Mount USB and press A twice to confirm. Your FunKey will now be visible as a USB drive on your computer. You can place your application in any 1 st -level folder, and you can create as many as you want to organise your applications. Let's create a new folder called Applications and place hello.opk in there. Safely remove the USB drive from your computer, and in the FunKey menu select Eject USB and press A twice to confirm. Your application is now installed on FunKey. Note that only the GMENU2X launcher can open custom applications . So switch to that launcher via the FunKey menu if you haven't already. You should find an application called Hello under the applications category in the launcher.","title":"Installing"},{"location":"developer_guide/tutorials/build_system/compilation_environments/","text":"Even if the resulting disk image and firmware update files are relatively small (202 MB and 55MB, respectively), the size of the corresponding sources and the compilation by-products tend to be rather large, such that an available disk space of at least 12GB is required during the build. And even if the resulting FunKey-OS boots in less than 5s, it still requires a considerable amount of time to compile: please account for 1 \u00bd hour on a modern multi-core CPU with SSD drives and a decent Internet bandwidth. The FunKey-OS is meant to be built on a native Ubuntu or Debian Linux host machine (Ubuntu 20.04 LTS in our case, but this should also work with other versions, too). And with only a few changes to the prerequisites, it can certainly be adapted to build on other common Linux distros. However, if your development machine does not match this setup, there are still several available solutions: use a lightweight container system such as Docker and run an Ubuntu or Debian Linux container in it use a VM (Virtual Machine), such as provided by VirtualBox and run an Ubuntu or Debian Linux in it for Windows 10 users, use the WSL2 (Windows System for Linux 2) subsystem and run an Ubuntu Linux distro in it In order to install one of these virtualized environments on your machine, please refer to the corresponding documentation. Build on a Physical/Virtual Machine \u00b6 Prerequisites \u00b6 While Buildroot itself will build most host packages it needs for the compilation, some standard Linux utilities are expected to be already installed on the host system. If not already present, you will need to install the following packages beforehand: bash bc binutils build-essential bzip2 ca-certificates cpio cvs expect file g++ gcc git gzip liblscp-dev libncurses5-dev locales make mercurial openssh-client patch perl procps python python-dev python3 python3-dev python3-distutils python3-setuptools rsync rsync sed subversion sudo tar unzip wget which xxd On Ubuntu/Debian Linux, this is achieved by running the following command: $ sudo apt install bash bc binutils build-essential bzip2 ca-certificates cpio cvs expect file g++ gcc git gzip liblscp-dev libncurses5-dev locales make mercurial openssh-client patch perl procps python python-dev python3 python3-dev python3-distutils python3-setuptools rsync rsync sed subversion sudo tar unzip wget which xxd Build in a Docker Container \u00b6 Prerequisites \u00b6 When using a Docker container, all the prerequisites are automatically installed. Build on Windows 10 with WSL2 \u00b6 Prerequisites \u00b6 First, make sure your version of Windows 10 is new enough. Press Win + R to open the Run window and type in winver to check your Windows version and build number. The version should be 1903 or higher, the build number 18362 or higher. Enabling Windows Features \u00b6 Some addition Windows features need to be enabled. Open the Windows Features window either by searching for \"Windows Features\" in the Start Menu, or by opening Settings -> Apps & features -> Optional features -> More Windows features . There ensure that both Virtual Machine Platform and Windows Subsystem for Linux are enabled. After pressing OK to confirm, Windows will ask you to reboot your computer to complete installation. Download the Linux kernel update package \u00b6 An additional update is required to run WSL2. Download and install the following package from Microsoft: WSL2 Linux kernel update package for x64 machines Set WSL2 as your default version (optional) \u00b6 You can run the following command in PowerShell to make WSL2 the default version. New installations of Linux distributions on Windows will then automatically use WSL2. Otherwise they will use WSL version 1 by default. wsl --set-default-version 2 Install Ubuntu using the Microsoft Store \u00b6 Now that WSL2 is ready to be used you can download a Linux distribution from the Microsoft Store. For this guide, it is recommended to install Ubuntu 20.04 LTS . After installing, Ubuntu can be started by either selecting it from the Start Menu or typing ubuntu2004 on the command prompt. The first time you run Ubuntu you will be asked to create a new user account with a username and password. These do not have to be the same as your Windows account. If you've enabled WSL2 as the default version in the previous step, Ubuntu will be automatically configured to use that version. If you haven't set WSL2 as default, or if you've installed Ubuntu before setting WSL2 as default, it's possible to manually change the version for this distro. First, open a PowerShell window and type the following command to list all installed Linux distributions: wsl --list --verbose Check the name of the distribution you want to upgrade and run: wsl --set-version <distribution name> <versionNumber> With <versionNumber> set to 2 to use WSL2. You can use the same command with version number 1 to return to WSL 1. WSL2 is now ready to be used \u00b6 Your Ubuntu installation is now ready to be used. Starting Ubuntu from the Start Menu will open a terminal with a Bash prompt. Everything you type here will be executed in Ubuntu. You can run and install applications within Ubuntu as you would on a complete installation or virtual machine. Follow the instructions in the Build on a Physical/Virtual Machine section to install the requirements needed to build FunKey-OS. You can access the Windows filesystem via /mnt ; the C: drive is mounted as /mnt/c . From Windows you can access the Linux filesystem via the special path \\\\wsl$ . Note that you can only access the files there when Ubuntu is running on WSL2.","title":"Compilation Environments"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#build-on-a-physicalvirtual-machine","text":"","title":"Build on a Physical/Virtual Machine"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#prerequisites","text":"While Buildroot itself will build most host packages it needs for the compilation, some standard Linux utilities are expected to be already installed on the host system. If not already present, you will need to install the following packages beforehand: bash bc binutils build-essential bzip2 ca-certificates cpio cvs expect file g++ gcc git gzip liblscp-dev libncurses5-dev locales make mercurial openssh-client patch perl procps python python-dev python3 python3-dev python3-distutils python3-setuptools rsync rsync sed subversion sudo tar unzip wget which xxd On Ubuntu/Debian Linux, this is achieved by running the following command: $ sudo apt install bash bc binutils build-essential bzip2 ca-certificates cpio cvs expect file g++ gcc git gzip liblscp-dev libncurses5-dev locales make mercurial openssh-client patch perl procps python python-dev python3 python3-dev python3-distutils python3-setuptools rsync rsync sed subversion sudo tar unzip wget which xxd","title":"Prerequisites"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#build-in-a-docker-container","text":"","title":"Build in a Docker Container"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#prerequisites_1","text":"When using a Docker container, all the prerequisites are automatically installed.","title":"Prerequisites"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#build-on-windows-10-with-wsl2","text":"","title":"Build on Windows 10 with WSL2"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#prerequisites_2","text":"First, make sure your version of Windows 10 is new enough. Press Win + R to open the Run window and type in winver to check your Windows version and build number. The version should be 1903 or higher, the build number 18362 or higher.","title":"Prerequisites"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#enabling-windows-features","text":"Some addition Windows features need to be enabled. Open the Windows Features window either by searching for \"Windows Features\" in the Start Menu, or by opening Settings -> Apps & features -> Optional features -> More Windows features . There ensure that both Virtual Machine Platform and Windows Subsystem for Linux are enabled. After pressing OK to confirm, Windows will ask you to reboot your computer to complete installation.","title":"Enabling Windows Features"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#download-the-linux-kernel-update-package","text":"An additional update is required to run WSL2. Download and install the following package from Microsoft: WSL2 Linux kernel update package for x64 machines","title":"Download the Linux kernel update package"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#set-wsl2-as-your-default-version-optional","text":"You can run the following command in PowerShell to make WSL2 the default version. New installations of Linux distributions on Windows will then automatically use WSL2. Otherwise they will use WSL version 1 by default. wsl --set-default-version 2","title":"Set WSL2 as your default version (optional)"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#install-ubuntu-using-the-microsoft-store","text":"Now that WSL2 is ready to be used you can download a Linux distribution from the Microsoft Store. For this guide, it is recommended to install Ubuntu 20.04 LTS . After installing, Ubuntu can be started by either selecting it from the Start Menu or typing ubuntu2004 on the command prompt. The first time you run Ubuntu you will be asked to create a new user account with a username and password. These do not have to be the same as your Windows account. If you've enabled WSL2 as the default version in the previous step, Ubuntu will be automatically configured to use that version. If you haven't set WSL2 as default, or if you've installed Ubuntu before setting WSL2 as default, it's possible to manually change the version for this distro. First, open a PowerShell window and type the following command to list all installed Linux distributions: wsl --list --verbose Check the name of the distribution you want to upgrade and run: wsl --set-version <distribution name> <versionNumber> With <versionNumber> set to 2 to use WSL2. You can use the same command with version number 1 to return to WSL 1.","title":"Install Ubuntu using the Microsoft Store"},{"location":"developer_guide/tutorials/build_system/compilation_environments/#wsl2-is-now-ready-to-be-used","text":"Your Ubuntu installation is now ready to be used. Starting Ubuntu from the Start Menu will open a terminal with a Bash prompt. Everything you type here will be executed in Ubuntu. You can run and install applications within Ubuntu as you would on a complete installation or virtual machine. Follow the instructions in the Build on a Physical/Virtual Machine section to install the requirements needed to build FunKey-OS. You can access the Windows filesystem via /mnt ; the C: drive is mounted as /mnt/c . From Windows you can access the Linux filesystem via the special path \\\\wsl$ . Note that you can only access the files there when Ubuntu is running on WSL2.","title":"WSL2 is now ready to be used"},{"location":"developer_guide/tutorials/build_system/compile_distribution/","text":"On a Physical Machine / In a Virtual Machine \u00b6 You may now build your FunKey with: $ make sdk all This may take a while (~1h30), so consider getting yourself a cup, a glass or a bottle of your favorite beverage ;-) Note : you will need to have access to the network, since buildroot will download the package sources. After building, you should obtain the SD Card image FunKey-sdcard-X.Y.Z.img , the SDK file FunKey-sdk-X.Y.Z.tar.gz and the firmware update file FunKey-rootfs-X.Y.fwu in the images directory. In a Docker Container \u00b6 You may now build your FunKey with: $ docker run --name funkey-os funkeyproject/funkey-os Or alternatively, you can run it in the background with: $ docker run -d --name funkey-os funkeyproject/funkey-os If you launch it in the background, you can still follow what is going on with either: $ docker top funkey-os Or: $ docker logs funkey-os This may take a while (~1h30), so consider getting yourself a cup, a glass or a bottle of your favorite beverage ;-) Note : you will need to have access to the network, since buildroot will download the package sources. After building, you can copy the SD Card image sdcard.img , the SDK file FunKey-sdk-X.Y.tar.gz and the firmware update file FunKey-rootfs-X.Y.fwu from the container into the host current directory: $ mkdir images $ docker cp funkey-os:/home/funkey/FunKey-OS/images/FunKey-sdcard-X.Y.Z.img images/ $ docker cp funkey-os:/home/funkey/FunKey-OS/images/FunKey-sdk-X.Y.Z.tar.gz images/ $ docker cp funkey-os:/home/funkey/FunKey-OS/images/FunKey-rootfs-X.Y.Z.fwu images/","title":"Compile Distribution"},{"location":"developer_guide/tutorials/build_system/compile_distribution/#on-a-physical-machine-in-a-virtual-machine","text":"You may now build your FunKey with: $ make sdk all This may take a while (~1h30), so consider getting yourself a cup, a glass or a bottle of your favorite beverage ;-) Note : you will need to have access to the network, since buildroot will download the package sources. After building, you should obtain the SD Card image FunKey-sdcard-X.Y.Z.img , the SDK file FunKey-sdk-X.Y.Z.tar.gz and the firmware update file FunKey-rootfs-X.Y.fwu in the images directory.","title":"On a Physical Machine / In a Virtual Machine"},{"location":"developer_guide/tutorials/build_system/compile_distribution/#in-a-docker-container","text":"You may now build your FunKey with: $ docker run --name funkey-os funkeyproject/funkey-os Or alternatively, you can run it in the background with: $ docker run -d --name funkey-os funkeyproject/funkey-os If you launch it in the background, you can still follow what is going on with either: $ docker top funkey-os Or: $ docker logs funkey-os This may take a while (~1h30), so consider getting yourself a cup, a glass or a bottle of your favorite beverage ;-) Note : you will need to have access to the network, since buildroot will download the package sources. After building, you can copy the SD Card image sdcard.img , the SDK file FunKey-sdk-X.Y.tar.gz and the firmware update file FunKey-rootfs-X.Y.fwu from the container into the host current directory: $ mkdir images $ docker cp funkey-os:/home/funkey/FunKey-OS/images/FunKey-sdcard-X.Y.Z.img images/ $ docker cp funkey-os:/home/funkey/FunKey-OS/images/FunKey-sdk-X.Y.Z.tar.gz images/ $ docker cp funkey-os:/home/funkey/FunKey-OS/images/FunKey-rootfs-X.Y.Z.fwu images/","title":"In a Docker Container"},{"location":"developer_guide/tutorials/build_system/compile_sdk/","text":"Starting from version 2.0.0, the pre-compiled FunKey SDK is available on Github , and it is also compiled automatically as a first step when building the full FunKey-OS distribution . However, if you want to compile the SDK only, here are the instructions below: On a Physical Machine / In a Virtual Machine \u00b6 You may now build the SDK with: $ make sdk This may take a while (~1h), so consider getting yourself a cup, a glass or a bottle of your favorite beverage ;-) Note : you will need to have access to the network, since buildroot will download the package sources. After building, you should obtain the SDK file FunKey-sdk-X.Y.Z.tar.gz in the images directory. In a Docker Container \u00b6 You may now build your FunKey with: $ docker run --name funkey-os funkeyproject/funkey-os make sdk -C /home/funkey/FunKey-OS Or alternatively, you can run it in the background with: $ docker run -d --name funkey-os funkeyproject/funkey-os make sdk -C /home/funkey/FunKey-OS If you launch it in the background, you can still follow what is going on with either: $ docker top funkey-os Or: $ docker logs funkey-os This may take a while (~1h), so consider getting yourself a cup, a glass or a bottle of your favorite beverage ;-) Note : you will need to have access to the network, since buildroot will download the package sources. After building, you can copy the SDK file FunKey-sdk-X.Y.tar.gz from the container into the host current directory: $ mkdir images $ docker cp funkey-os:/home/funkey/FunKey-OS/images/FunKey-sdk-X.Y.Z.tar.gz images/","title":"Compile SDK"},{"location":"developer_guide/tutorials/build_system/compile_sdk/#on-a-physical-machine-in-a-virtual-machine","text":"You may now build the SDK with: $ make sdk This may take a while (~1h), so consider getting yourself a cup, a glass or a bottle of your favorite beverage ;-) Note : you will need to have access to the network, since buildroot will download the package sources. After building, you should obtain the SDK file FunKey-sdk-X.Y.Z.tar.gz in the images directory.","title":"On a Physical Machine / In a Virtual Machine"},{"location":"developer_guide/tutorials/build_system/compile_sdk/#in-a-docker-container","text":"You may now build your FunKey with: $ docker run --name funkey-os funkeyproject/funkey-os make sdk -C /home/funkey/FunKey-OS Or alternatively, you can run it in the background with: $ docker run -d --name funkey-os funkeyproject/funkey-os make sdk -C /home/funkey/FunKey-OS If you launch it in the background, you can still follow what is going on with either: $ docker top funkey-os Or: $ docker logs funkey-os This may take a while (~1h), so consider getting yourself a cup, a glass or a bottle of your favorite beverage ;-) Note : you will need to have access to the network, since buildroot will download the package sources. After building, you can copy the SDK file FunKey-sdk-X.Y.tar.gz from the container into the host current directory: $ mkdir images $ docker cp funkey-os:/home/funkey/FunKey-OS/images/FunKey-sdk-X.Y.Z.tar.gz images/","title":"In a Docker Container"},{"location":"developer_guide/tutorials/build_system/get_sources/","text":"On a Physical Machine / In a Virtual Machine \u00b6 When using either physical Linux machine or virtual Linux machines (VirtualBox or WSL2), you must clone the FunKey OS repository from Github (here we place it into a FunKey-OS directory): $ git clone https://github.com/FunKey-Project/FunKey-OS.git FunKey-OS Then enter into the newly created directory: $ cd FunKey-OS In a Docker Container \u00b6 When using a Docker container, you must first create a new directory (here we create a FunKey-OS directory) and get the FunKey-OS Dockerfile in it: $ mkdir FunKey-OS $ cd FunKey-OS $ wget https://raw.githubusercontent.com/FunKey-Project/FunKey-OS/master/docker/Dockerfile -o Dockerfile You must then build the docker image (don't forget the final dot!): $ docker build -t funkeyproject/funkey-os .","title":"Get the Sources"},{"location":"developer_guide/tutorials/build_system/get_sources/#on-a-physical-machine-in-a-virtual-machine","text":"When using either physical Linux machine or virtual Linux machines (VirtualBox or WSL2), you must clone the FunKey OS repository from Github (here we place it into a FunKey-OS directory): $ git clone https://github.com/FunKey-Project/FunKey-OS.git FunKey-OS Then enter into the newly created directory: $ cd FunKey-OS","title":"On a Physical Machine / In a Virtual Machine"},{"location":"developer_guide/tutorials/build_system/get_sources/#in-a-docker-container","text":"When using a Docker container, you must first create a new directory (here we create a FunKey-OS directory) and get the FunKey-OS Dockerfile in it: $ mkdir FunKey-OS $ cd FunKey-OS $ wget https://raw.githubusercontent.com/FunKey-Project/FunKey-OS/master/docker/Dockerfile -o Dockerfile You must then build the docker image (don't forget the final dot!): $ docker build -t funkeyproject/funkey-os .","title":"In a Docker Container"},{"location":"developer_guide/tutorials/build_system/write_image/","text":"How to Flash the Firmware to the SD Card \u00b6 You can copy the bootable images/sdcard.img onto an SD card using \"dd\": $ sudo dd if = images/FunKey-sdcard-X.Y.Z.img of = /dev/sdX Warning : Please make sure that /dev/sdX device corresponds to your SD Card, otherwise you may wipe out one of your hard drive partitions! Alternatively, you can use the Balena-Etcher graphical tool to burn the image to the SD card safely and on any platform: https://www.balena.io/etcher/ Once the SD card is burnt, insert it into the FunKey S console slot, and power it up. Your new system should come up now and start a console on the UART0 serial port and display the RetroFE game launcher on the graphical screen. How to Update the FunKey S Firmware \u00b6 It is possible to update the FunKey-S over USB , please follow the steps described in the Firmware Upgrade section.","title":"Write firmware to SD Card"},{"location":"developer_guide/tutorials/build_system/write_image/#how-to-flash-the-firmware-to-the-sd-card","text":"You can copy the bootable images/sdcard.img onto an SD card using \"dd\": $ sudo dd if = images/FunKey-sdcard-X.Y.Z.img of = /dev/sdX Warning : Please make sure that /dev/sdX device corresponds to your SD Card, otherwise you may wipe out one of your hard drive partitions! Alternatively, you can use the Balena-Etcher graphical tool to burn the image to the SD card safely and on any platform: https://www.balena.io/etcher/ Once the SD card is burnt, insert it into the FunKey S console slot, and power it up. Your new system should come up now and start a console on the UART0 serial port and display the RetroFE game launcher on the graphical screen.","title":"How to Flash the Firmware to the SD Card"},{"location":"developer_guide/tutorials/build_system/write_image/#how-to-update-the-funkey-s-firmware","text":"It is possible to update the FunKey-S over USB , please follow the steps described in the Firmware Upgrade section.","title":"How to Update the FunKey S Firmware"},{"location":"miscellaneous/faq/","text":"","title":"FAQ"},{"location":"miscellaneous/glossary/","text":"A \u00b6 ADC : Analog to Digital Converter C \u00b6 CPU : Central Processing Unit CSi : Camera Serial Interface D \u00b6 DAC : Digital to Analog Converter DFU : Device Firmware Update DMA : Direct Memory Access DDR : Dual Data Rate DRAM : Dynamic Random-Access Memory DSi : Display Serial Interface E \u00b6 ERC : Electrical Rule Check ESD : Electro-Static Discharge F \u00b6 FPU : Floating Point Unit G \u00b6 GPIO : General-Purpose Input/Output GPU : Graphic Processing Unit I \u00b6 I/O : Input/Output I2C : Inter-Integrated Circuit Bus IPS : In-Plane Switching or Intelligent Power Select IRQ : Interrupt ReQuest L \u00b6 LED : Ligh-Emitting Diode LCD : Liquid-Crystal Display LDO : Low Drop-Out LiPo : Lithium Polymer M \u00b6 MMU : Memory Management Unit MIPI : Mobile Industry Processor Interface N \u00b6 NTC : Negative Temperature Coefficient O \u00b6 OPK : Open Package OTG : On-The-Go P \u00b6 PCBA : Printed Circuit Board Assembly PCB : Printed Circuit Board PIO : Peripheral I/O PLL : Phase-Locked Loop PMIC : Power Management Integrated Circuit PMU : Power Managment Unit PoP : Package on Package PSRR : Power Supply Rejection Ratio PWM : Pulse Width Modulation R \u00b6 RAM : Random-Access Memory ROM : Read-Only Memory RTC : Real-Time Clock S \u00b6 SD : Secure Digital SIMD : Single Instruction Multiple Data SiP : System in Package SMPS : Switched-Mode Power Supply SoC : System on Chip SPI : Serial Peripheral Interface SPL : Secondary Program Loader SRAM : Static Random-Access Memory T \u00b6 TFT LCD : Thin-Film-Transistor Liquid-Crystal Display TVS : Transcient Voltage Suppressor U \u00b6 UART : Universal Asynchronous Receiver/Transmitter USB : Universal Serial Bus","title":"Glossary"},{"location":"miscellaneous/glossary/#a","text":"ADC : Analog to Digital Converter","title":"A"},{"location":"miscellaneous/glossary/#c","text":"CPU : Central Processing Unit CSi : Camera Serial Interface","title":"C"},{"location":"miscellaneous/glossary/#d","text":"DAC : Digital to Analog Converter DFU : Device Firmware Update DMA : Direct Memory Access DDR : Dual Data Rate DRAM : Dynamic Random-Access Memory DSi : Display Serial Interface","title":"D"},{"location":"miscellaneous/glossary/#e","text":"ERC : Electrical Rule Check ESD : Electro-Static Discharge","title":"E"},{"location":"miscellaneous/glossary/#f","text":"FPU : Floating Point Unit","title":"F"},{"location":"miscellaneous/glossary/#g","text":"GPIO : General-Purpose Input/Output GPU : Graphic Processing Unit","title":"G"},{"location":"miscellaneous/glossary/#i","text":"I/O : Input/Output I2C : Inter-Integrated Circuit Bus IPS : In-Plane Switching or Intelligent Power Select IRQ : Interrupt ReQuest","title":"I"},{"location":"miscellaneous/glossary/#l","text":"LED : Ligh-Emitting Diode LCD : Liquid-Crystal Display LDO : Low Drop-Out LiPo : Lithium Polymer","title":"L"},{"location":"miscellaneous/glossary/#m","text":"MMU : Memory Management Unit MIPI : Mobile Industry Processor Interface","title":"M"},{"location":"miscellaneous/glossary/#n","text":"NTC : Negative Temperature Coefficient","title":"N"},{"location":"miscellaneous/glossary/#o","text":"OPK : Open Package OTG : On-The-Go","title":"O"},{"location":"miscellaneous/glossary/#p","text":"PCBA : Printed Circuit Board Assembly PCB : Printed Circuit Board PIO : Peripheral I/O PLL : Phase-Locked Loop PMIC : Power Management Integrated Circuit PMU : Power Managment Unit PoP : Package on Package PSRR : Power Supply Rejection Ratio PWM : Pulse Width Modulation","title":"P"},{"location":"miscellaneous/glossary/#r","text":"RAM : Random-Access Memory ROM : Read-Only Memory RTC : Real-Time Clock","title":"R"},{"location":"miscellaneous/glossary/#s","text":"SD : Secure Digital SIMD : Single Instruction Multiple Data SiP : System in Package SMPS : Switched-Mode Power Supply SoC : System on Chip SPI : Serial Peripheral Interface SPL : Secondary Program Loader SRAM : Static Random-Access Memory","title":"S"},{"location":"miscellaneous/glossary/#t","text":"TFT LCD : Thin-Film-Transistor Liquid-Crystal Display TVS : Transcient Voltage Suppressor","title":"T"},{"location":"miscellaneous/glossary/#u","text":"UART : Universal Asynchronous Receiver/Transmitter USB : Universal Serial Bus","title":"U"},{"location":"user_manual/quickstart/","text":"","title":"Quickstart"},{"location":"user_manual/features/emulators/","text":"","title":"Emulators"},{"location":"user_manual/features/folder_organization/","text":"","title":"Folder Organization"},{"location":"user_manual/features/funkey_menu/","text":"","title":"FunKey Menu"},{"location":"user_manual/features/games_apps/","text":"","title":"Standalone Games & Applications"},{"location":"user_manual/features/hardware_characteristics/","text":"","title":"Hardware Characteristics"},{"location":"user_manual/features/instant_action/","text":"","title":"Instant Action"},{"location":"user_manual/features/key_mapping/","text":"","title":"Key Mapping"},{"location":"user_manual/features/launchers/","text":"","title":"Launchers"},{"location":"user_manual/features/open_source/","text":"","title":"Open Source"},{"location":"user_manual/features/quick_save/","text":"","title":"Quick Save"},{"location":"user_manual/tutorials/hardware/change_buttons/","text":"You FunKey S is delivered with 4 extra sets of buttons (red, blue, yellow and green) so that you can customize them at will. It only requires a standard Phillips screwdriver (PH0) , tweezers and a knife or scissors for cutting up the plastic holding the new buttons together. Note Be careful when opening up the console. FunKey Project is not responsible for any damage done to your console when changing the buttons. STEP 1 - Removing the screws \u00b6 Using a standard Phillips PH0 screwdriver , remove the 2 screws on the back of your FunKey S. Warning Be careful to use the correct screwdriver head size and type to prevent damaging the screws (do not use JIS screwdrivers). FunKey Project is not responsible for replacing damaged screws. STEP 2 - Opening up the console \u00b6 Carefully remove the plastic back of the console by pulling up the hinge side first STEP 3 - Removing the keychain lanyard \u00b6 Carefully remove the keychain lanyard and its axis by pulling gently (it may fall off when opening). Warning The axis is a small part, be careful not to loose it. STEP 4 - Removing the LR buttons \u00b6 Carefully remove the L/R plastic buttons by gently pulling them out of their axis Warning Be careful not to damage the L/R switches on the circuit board! STEP 5 - Unplugging the battery \u00b6 Note This step is not required for changing the buttons, but we still advise it. You can however jump to the next step and not unplug the battery. Lift the battery and pull gently by the top of the circuit board to unplug the battery. The battery may be stuck to the processor with double-sided adhesive, it's perfectly normal if you have to lift with a bit of force to unstick it. Warning Be sure to pull on the connector and NOT the wires when removing the battery. It is recommended to use tweezers. STEP 6 - Unplugging the screen \u00b6 Now that you have access to the circuit board, you can unplug the screen. Warning This connector is fragile, unplug it vertically without force. It is recommended to use tweezers. STEP 7 - Removing the circuit board \u00b6 By grabbing it by the hinge side , gently pull up the circuit board from the plastic casing. STEP 8 - Removing the buttons you wish to change \u00b6 Remove the buttons from their socket. It is recommended to use tweezers. STEP 9 - Separating the new buttons \u00b6 Cut up the buttons from the four sets of colors included with your FunKey S. In this exemple one of the A/B/X/Y button is cut from each color. Warning When replacing a specific button, for example the top arrow, you need to get the same exact button (top arrow). For example a left arrow should not replace a top arrow or the console might not close properly when reassembling it. STEP 10 - Assembling the new buttons \u00b6 Reassemble the new cut buttons in their hole. STEP 11 - Reassembly \u00b6 Insert first the speaker into its location in the casing before putting the circuit board back in the case, like in the pictures. Reassemble the console by following the previous steps in reverse order. Warning Be careful not to damage the switches on the circuit board when putting back the L/R plastic buttons.","title":"Change the Buttons"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-1-removing-the-screws","text":"Using a standard Phillips PH0 screwdriver , remove the 2 screws on the back of your FunKey S. Warning Be careful to use the correct screwdriver head size and type to prevent damaging the screws (do not use JIS screwdrivers). FunKey Project is not responsible for replacing damaged screws.","title":"STEP 1 - Removing the screws"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-2-opening-up-the-console","text":"Carefully remove the plastic back of the console by pulling up the hinge side first","title":"STEP 2 - Opening up the console"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-3-removing-the-keychain-lanyard","text":"Carefully remove the keychain lanyard and its axis by pulling gently (it may fall off when opening). Warning The axis is a small part, be careful not to loose it.","title":"STEP 3 - Removing the keychain lanyard"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-4-removing-the-lr-buttons","text":"Carefully remove the L/R plastic buttons by gently pulling them out of their axis Warning Be careful not to damage the L/R switches on the circuit board!","title":"STEP 4 - Removing the LR buttons"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-5-unplugging-the-battery","text":"Note This step is not required for changing the buttons, but we still advise it. You can however jump to the next step and not unplug the battery. Lift the battery and pull gently by the top of the circuit board to unplug the battery. The battery may be stuck to the processor with double-sided adhesive, it's perfectly normal if you have to lift with a bit of force to unstick it. Warning Be sure to pull on the connector and NOT the wires when removing the battery. It is recommended to use tweezers.","title":"STEP 5 - Unplugging the battery"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-6-unplugging-the-screen","text":"Now that you have access to the circuit board, you can unplug the screen. Warning This connector is fragile, unplug it vertically without force. It is recommended to use tweezers.","title":"STEP 6 - Unplugging the screen"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-7-removing-the-circuit-board","text":"By grabbing it by the hinge side , gently pull up the circuit board from the plastic casing.","title":"STEP 7 - Removing the circuit board"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-8-removing-the-buttons-you-wish-to-change","text":"Remove the buttons from their socket. It is recommended to use tweezers.","title":"STEP 8 - Removing the buttons you wish to change"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-9-separating-the-new-buttons","text":"Cut up the buttons from the four sets of colors included with your FunKey S. In this exemple one of the A/B/X/Y button is cut from each color. Warning When replacing a specific button, for example the top arrow, you need to get the same exact button (top arrow). For example a left arrow should not replace a top arrow or the console might not close properly when reassembling it.","title":"STEP 9 - Separating the new buttons"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-10-assembling-the-new-buttons","text":"Reassemble the new cut buttons in their hole.","title":"STEP 10 - Assembling the new buttons"},{"location":"user_manual/tutorials/hardware/change_buttons/#step-11-reassembly","text":"Insert first the speaker into its location in the casing before putting the circuit board back in the case, like in the pictures. Reassemble the console by following the previous steps in reverse order. Warning Be careful not to damage the switches on the circuit board when putting back the L/R plastic buttons.","title":"STEP 11 - Reassembly"},{"location":"user_manual/tutorials/hardware/fix_unstuck_screen/","text":"Fix Loose Glass \u00b6 Some FunKey S consoles coming from the first production batch might have an issue with the front glass not sticking correctly to the left side of the casing: The following tutorial explains how to simply stick back the screen using standard cyanoacrylate glue. The necessary material is: Standard cyanoacrylate glue (US: Gorilla Super Glue, Europe: Loctite Superglue) A toothpick Tape STEP 1 - Protect the plastic casing with tape \u00b6 Stick a piece of tape on the plastic casing to the left side of the screen. This will avoid any glue spilling on it. STEP 2 - Prepare the glue \u00b6 Appy one drop of glue on a flat waterproof surface (such as the back of some tape for example). One drop is enough. STEP 3 - Apply the glue \u00b6 Dip the tip of the toothpick in the glue and apply it inside the plastic casing alongside the left edge. Multiple dips can be necessary to cover the whole side. The toothpick tip will soften with the glue and act as a paintbrush. Warning Be careful not to put too much glue in the casing! STEP 4 - Stick the glass \u00b6 Use your thumb to apply force on the left side of the glass for at least 2 minutes (the longer the better, this leaves more time for the glue to stick). You can remove the protective tape in the meantime. STEP 5 - All done \u00b6 The glass should now hold tightly to the left side of the casing, you are ready to play!","title":""},{"location":"user_manual/tutorials/hardware/fix_unstuck_screen/#fix-loose-glass","text":"Some FunKey S consoles coming from the first production batch might have an issue with the front glass not sticking correctly to the left side of the casing: The following tutorial explains how to simply stick back the screen using standard cyanoacrylate glue. The necessary material is: Standard cyanoacrylate glue (US: Gorilla Super Glue, Europe: Loctite Superglue) A toothpick Tape","title":"Fix Loose Glass"},{"location":"user_manual/tutorials/hardware/fix_unstuck_screen/#step-1-protect-the-plastic-casing-with-tape","text":"Stick a piece of tape on the plastic casing to the left side of the screen. This will avoid any glue spilling on it.","title":"STEP 1 - Protect the plastic casing with tape"},{"location":"user_manual/tutorials/hardware/fix_unstuck_screen/#step-2-prepare-the-glue","text":"Appy one drop of glue on a flat waterproof surface (such as the back of some tape for example). One drop is enough.","title":"STEP 2 - Prepare the glue"},{"location":"user_manual/tutorials/hardware/fix_unstuck_screen/#step-3-apply-the-glue","text":"Dip the tip of the toothpick in the glue and apply it inside the plastic casing alongside the left edge. Multiple dips can be necessary to cover the whole side. The toothpick tip will soften with the glue and act as a paintbrush. Warning Be careful not to put too much glue in the casing!","title":"STEP 3 - Apply the glue"},{"location":"user_manual/tutorials/hardware/fix_unstuck_screen/#step-4-stick-the-glass","text":"Use your thumb to apply force on the left side of the glass for at least 2 minutes (the longer the better, this leaves more time for the glue to stick). You can remove the protective tape in the meantime.","title":"STEP 4 - Stick the glass"},{"location":"user_manual/tutorials/hardware/fix_unstuck_screen/#step-5-all-done","text":"The glass should now hold tightly to the left side of the casing, you are ready to play!","title":"STEP 5 - All done"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/","text":"Flashing a new micro- SD card \u00b6 The following steps describe how to flash a micro- SD card with the latest version of FunKey-OS. This must be done before switching micro- SD cards inside the console. Note: Everything on the micro- SD card will be lost, be sure to save your data. Download the latest FunKey-OS image file \u00b6 Get the latest \" FunKey-rootfs-x.y.z.img \" SD card image file directly from here or from the bottom of the latest release page in the \"assets\" section: https://github.com/FunKey-Project/FunKey-OS/releases/latest Flash the micro- SD card with balenaEtcher \u00b6 Download and install balenaEtcher for Windows/Mac OS/Linux from balena.io Run balenaEtcher and click on \"Flash from file\" to select the FunKey-OS image file Insert the micro- SD card in your computer and select the SD card drive (balenaEtcher should automatically detect it for you) Finally, click Flash You'll see a progress bar. Once complete, make sure the flashing was successful, otherwise retry to flash the SD card . The program will automatically unmount the SD card so it's safe to remove it from your computer. Switching micro- SD cards \u00b6 On the FunKey S , the micro- SD card was voluntarily placed against the casing so that it has no degree of freedom and cannot move by accident during the eventful life of a keychain. Removing/switching the micro- SD card was nevertheless designed to be pretty straightforward and only require a standard Phillips screwdriver (PH0) and optionally some tweezers . Please follow the steps below carefully: STEP 1 - Removing the screws \u00b6 Using a standard Phillips PH0 screwdriver , remove the 2 screws on the back of your FunKey S. Warning Be careful to use the correct screwdriver head size and type to prevent damaging the screws (do not use JIS screwdrivers!). FunKey Project is not responsible for replacing damaged screws. STEP 2 - Opening up the console \u00b6 Carefully remove: The plastic back of the console by pulling up the hinge side first The L/R plastic buttons by gently pulling them up out of their axis The keychain lanyard and axis Warning Be careful not to damage the L/R switches on the circuit board! STEP 3 - Exposing the circuit board \u00b6 Remove the keychain lanyard axis, as it may fall off when opening. Lift the battery (but leave it connected) to expose the circuit board. STEP 4 - Accessing the SD card \u00b6 By grabbing it by the micro- USB port , gently pull up the circuit board until you have access to the SD card. STEP 5 - Switching SD cards \u00b6 You can now remove the old micro- SD card from its socket and insert the new one (previously flashed as described in the 1 st part of this tutorial ). Note You may need to use some tweezers and pull with some strength in order to remove the micro- SD card from its socket, as it is strongly inserted to prevent loose connections. STEP 6 - Reassembly \u00b6 Insert first the speaker into its location in the casing before putting the circuit board back in the case, like in the pictures. Reassemble the console by following the previous steps in reverse order. Warning Be careful not to damage the switches on the circuit board when putting back the L/R plastic buttons.","title":"Flash & Change micro-SD Card"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#flashing-a-new-micro-sd-card","text":"The following steps describe how to flash a micro- SD card with the latest version of FunKey-OS. This must be done before switching micro- SD cards inside the console. Note: Everything on the micro- SD card will be lost, be sure to save your data.","title":"Flashing a new micro-SD card"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#download-the-latest-funkey-os-image-file","text":"Get the latest \" FunKey-rootfs-x.y.z.img \" SD card image file directly from here or from the bottom of the latest release page in the \"assets\" section: https://github.com/FunKey-Project/FunKey-OS/releases/latest","title":"Download the latest FunKey-OS image file"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#flash-the-micro-sd-card-with-balenaetcher","text":"Download and install balenaEtcher for Windows/Mac OS/Linux from balena.io Run balenaEtcher and click on \"Flash from file\" to select the FunKey-OS image file Insert the micro- SD card in your computer and select the SD card drive (balenaEtcher should automatically detect it for you) Finally, click Flash You'll see a progress bar. Once complete, make sure the flashing was successful, otherwise retry to flash the SD card . The program will automatically unmount the SD card so it's safe to remove it from your computer.","title":"Flash the micro-SD card with balenaEtcher"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#switching-micro-sd-cards","text":"On the FunKey S , the micro- SD card was voluntarily placed against the casing so that it has no degree of freedom and cannot move by accident during the eventful life of a keychain. Removing/switching the micro- SD card was nevertheless designed to be pretty straightforward and only require a standard Phillips screwdriver (PH0) and optionally some tweezers . Please follow the steps below carefully:","title":"Switching micro-SD cards"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#step-1-removing-the-screws","text":"Using a standard Phillips PH0 screwdriver , remove the 2 screws on the back of your FunKey S. Warning Be careful to use the correct screwdriver head size and type to prevent damaging the screws (do not use JIS screwdrivers!). FunKey Project is not responsible for replacing damaged screws.","title":"STEP 1 - Removing the screws"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#step-2-opening-up-the-console","text":"Carefully remove: The plastic back of the console by pulling up the hinge side first The L/R plastic buttons by gently pulling them up out of their axis The keychain lanyard and axis Warning Be careful not to damage the L/R switches on the circuit board!","title":"STEP 2 - Opening up the console"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#step-3-exposing-the-circuit-board","text":"Remove the keychain lanyard axis, as it may fall off when opening. Lift the battery (but leave it connected) to expose the circuit board.","title":"STEP 3 - Exposing the circuit board"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#step-4-accessing-the-sd-card","text":"By grabbing it by the micro- USB port , gently pull up the circuit board until you have access to the SD card.","title":"STEP 4 - Accessing the SD card"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#step-5-switching-sd-cards","text":"You can now remove the old micro- SD card from its socket and insert the new one (previously flashed as described in the 1 st part of this tutorial ). Note You may need to use some tweezers and pull with some strength in order to remove the micro- SD card from its socket, as it is strongly inserted to prevent loose connections.","title":"STEP 5 - Switching SD cards"},{"location":"user_manual/tutorials/hardware/flash_change_sd_card/#step-6-reassembly","text":"Insert first the speaker into its location in the casing before putting the circuit board back in the case, like in the pictures. Reassemble the console by following the previous steps in reverse order. Warning Be careful not to damage the switches on the circuit board when putting back the L/R plastic buttons.","title":"STEP 6 - Reassembly"},{"location":"user_manual/tutorials/hardware/teardown/","text":"The FunKey S teardown was designed to be pretty straightforward. It only require a standard Phillips screwdriver (PH0) and tweezers . Note FunKey Project is not responsible for any damage done to your console during a teardown. STEP 1 - Removing the screws \u00b6 Using a standard Phillips PH0 screwdriver , remove the 2 screws on the back of your FunKey S. Warning Be careful to use the correct screwdriver head size and type to prevent damaging the screws (do not use JIS screwdrivers). FunKey Project is not responsible for replacing damaged screws. STEP 2 - Opening up the console \u00b6 Carefully remove the plastic back of the console by pulling up the hinge side first STEP 3 - Removing the keychain lanyard \u00b6 Carefully remove the keychain lanyard and its axis by pulling gently (it may fall off when opening). Warning The axis is a small part, be careful not to loose it. STEP 4 - Removing the LR buttons \u00b6 Carefully remove the L/R plastic buttons by gently pulling them out of their axis. Warning Be careful not to damage the L/R switches on the circuit board! STEP 5 - Unplugging the battery \u00b6 Lift the battery and pull gently by the top of the circuit board to unplug the battery. The battery may be stuck to the processor with double-sided adhesive, it's perfectly normal if you have to lift with a bit of force to unstick it. Warning Be sure to pull on the connector and NOT the wires when removing the battery. It is recommended to use tweezers. STEP 6 - Unplugging the screen \u00b6 Now that you have access to the circuit board, you can unplug the screen. Warning This connector is fragile, unplug it vertically without force. It is recommended to use tweezers. STEP 7 - Removing the circuit board \u00b6 By grabbing it by the hinge side , gently pull up the circuit board from the plastic casing. STEP 8 - Removing the micro- SD card \u00b6 Remove the micro- SD card from its socket. Note You may need to use some tweezers and pull with some strength in order to remove the micro- SD card from its socket, as it is strongly inserted to prevent loose connections. Warning During this step be very careful not to damage the L/R switches. Never put the PCB on a flat surface (this would apply force on the LR switches) and do not grab the PCB by these switches. STEP 9 - Removing the buttons \u00b6 Remove the buttons from their socket. It is recommended to use tweezers. STEP 10 - Teardown complete \u00b6 Good job the teardown is complete! STEP 11 - Reassembly \u00b6 Insert first the speaker into its location in the casing before putting the circuit board back in the case, like in the pictures. Reassemble the console by following the previous steps in reverse order. Warning Be careful not to damage the switches on the circuit board when putting back the L/R plastic buttons.","title":"Teardown"},{"location":"user_manual/tutorials/hardware/teardown/#step-1-removing-the-screws","text":"Using a standard Phillips PH0 screwdriver , remove the 2 screws on the back of your FunKey S. Warning Be careful to use the correct screwdriver head size and type to prevent damaging the screws (do not use JIS screwdrivers). FunKey Project is not responsible for replacing damaged screws.","title":"STEP 1 - Removing the screws"},{"location":"user_manual/tutorials/hardware/teardown/#step-2-opening-up-the-console","text":"Carefully remove the plastic back of the console by pulling up the hinge side first","title":"STEP 2 - Opening up the console"},{"location":"user_manual/tutorials/hardware/teardown/#step-3-removing-the-keychain-lanyard","text":"Carefully remove the keychain lanyard and its axis by pulling gently (it may fall off when opening). Warning The axis is a small part, be careful not to loose it.","title":"STEP 3 - Removing the keychain lanyard"},{"location":"user_manual/tutorials/hardware/teardown/#step-4-removing-the-lr-buttons","text":"Carefully remove the L/R plastic buttons by gently pulling them out of their axis. Warning Be careful not to damage the L/R switches on the circuit board!","title":"STEP 4 - Removing the LR buttons"},{"location":"user_manual/tutorials/hardware/teardown/#step-5-unplugging-the-battery","text":"Lift the battery and pull gently by the top of the circuit board to unplug the battery. The battery may be stuck to the processor with double-sided adhesive, it's perfectly normal if you have to lift with a bit of force to unstick it. Warning Be sure to pull on the connector and NOT the wires when removing the battery. It is recommended to use tweezers.","title":"STEP 5 - Unplugging the battery"},{"location":"user_manual/tutorials/hardware/teardown/#step-6-unplugging-the-screen","text":"Now that you have access to the circuit board, you can unplug the screen. Warning This connector is fragile, unplug it vertically without force. It is recommended to use tweezers.","title":"STEP 6 - Unplugging the screen"},{"location":"user_manual/tutorials/hardware/teardown/#step-7-removing-the-circuit-board","text":"By grabbing it by the hinge side , gently pull up the circuit board from the plastic casing.","title":"STEP 7 - Removing the circuit board"},{"location":"user_manual/tutorials/hardware/teardown/#step-8-removing-the-micro-sd-card","text":"Remove the micro- SD card from its socket. Note You may need to use some tweezers and pull with some strength in order to remove the micro- SD card from its socket, as it is strongly inserted to prevent loose connections. Warning During this step be very careful not to damage the L/R switches. Never put the PCB on a flat surface (this would apply force on the LR switches) and do not grab the PCB by these switches.","title":"STEP 8 - Removing the micro-SD card"},{"location":"user_manual/tutorials/hardware/teardown/#step-9-removing-the-buttons","text":"Remove the buttons from their socket. It is recommended to use tweezers.","title":"STEP 9 - Removing the buttons"},{"location":"user_manual/tutorials/hardware/teardown/#step-10-teardown-complete","text":"Good job the teardown is complete!","title":"STEP 10 - Teardown complete"},{"location":"user_manual/tutorials/hardware/teardown/#step-11-reassembly","text":"Insert first the speaker into its location in the casing before putting the circuit board back in the case, like in the pictures. Reassemble the console by following the previous steps in reverse order. Warning Be careful not to damage the switches on the circuit board when putting back the L/R plastic buttons.","title":"STEP 11 - Reassembly"},{"location":"user_manual/tutorials/software/add_opk/","text":"OPK (Open PacKage) files are archive files that contains emulators, standalone games, applications or utilities along with all their associated resources like icons packed into a single file that does not require installation to be able to run them. Note In the current (2.0.0) release of the FunKey-OS, the OPK files are only available for the gmenu2x launcher, and not in RetroFE. 7-Zip can be used to extract OPK files, and Open Package Creator (v1.1.2) is a useful tool if you want to re-package an OPK or customize icons, add additional games and much more. Connect your FunKey S console to your computer and add OPK files as simply as you would do it with a simple USB memory stick: Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with gmenu2x), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop the OPK file into any 1 st -level folder 1 in this USB drive on your computer and they will be automatically available on the FunKey S Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen Of course, you can remove OPK files from the FunKey S console as you would do with a USB memory stick, too! You can create additional 1 st -level folders in order to organize your OPK files just like you want. \u21a9","title":"Add OPK Files"},{"location":"user_manual/tutorials/software/add_roms/","text":"How to Get ROMs Legally \u00b6 Yes legally! Despite the general opinion, it is perfectly possible to purchase and play famous ROMs legally such as Sonic, Castlevania, Megaman and more, read the note below for more details. The FunKey Wiki maintains lists of legal sources for ROMs, including freeware ROMs , commercial ROMs , and utilities . Note about ROM emulation While ROM emulation is often seen as illegal, and sometimes by extension emulation itself, it is simply not true . Emulating hardware is perfectly legal, no gray area about this. Sharing a software copy though is illegal, so websites that host copied ROMs or bios are illegal, as well as downloading ROMs or bios from them. However, if some videogame companies have decided not to share their games as ROMs, it is not the case for all of them. Many companies, even such giants as SEGA, ATARI or Konami sell their retro-games online as ROMs. For example, it is perfectly legal to purchase the SEGA Mega Drive and Genesis Classics on Steam and play Sonic on your FunKey S . Add ROMs to the FunKey S \u00b6 Connect your FunKey S console to your computer and add new games as simply as you would do it with a simple USB memory stick: Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop the ROM file and optional artwork file into the folder corresponding to the emulated console in this USB drive on your computer The artwork file must have the same base name as the ROM file with a .png or .jpg extension. It is recommended to resize the artwork to a maximum dimension of 240px (big files will make scrolling less fluid on the launcher) An extensive list of artwork files (already resized to 240x240) has been made by Coolie Coolster here . An otherwise complete list of artwork can be found here . Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen Of course, you can remove games from the FunKey S console as you would do with a USB memory stick, too!","title":"Add New ROMs"},{"location":"user_manual/tutorials/software/add_roms/#how-to-get-roms-legally","text":"Yes legally! Despite the general opinion, it is perfectly possible to purchase and play famous ROMs legally such as Sonic, Castlevania, Megaman and more, read the note below for more details. The FunKey Wiki maintains lists of legal sources for ROMs, including freeware ROMs , commercial ROMs , and utilities . Note about ROM emulation While ROM emulation is often seen as illegal, and sometimes by extension emulation itself, it is simply not true . Emulating hardware is perfectly legal, no gray area about this. Sharing a software copy though is illegal, so websites that host copied ROMs or bios are illegal, as well as downloading ROMs or bios from them. However, if some videogame companies have decided not to share their games as ROMs, it is not the case for all of them. Many companies, even such giants as SEGA, ATARI or Konami sell their retro-games online as ROMs. For example, it is perfectly legal to purchase the SEGA Mega Drive and Genesis Classics on Steam and play Sonic on your FunKey S .","title":"How to Get ROMs Legally"},{"location":"user_manual/tutorials/software/add_roms/#add-roms-to-the-funkey-s","text":"Connect your FunKey S console to your computer and add new games as simply as you would do it with a simple USB memory stick: Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop the ROM file and optional artwork file into the folder corresponding to the emulated console in this USB drive on your computer The artwork file must have the same base name as the ROM file with a .png or .jpg extension. It is recommended to resize the artwork to a maximum dimension of 240px (big files will make scrolling less fluid on the launcher) An extensive list of artwork files (already resized to 240x240) has been made by Coolie Coolster here . An otherwise complete list of artwork can be found here . Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen Of course, you can remove games from the FunKey S console as you would do with a USB memory stick, too!","title":"Add ROMs to the FunKey S"},{"location":"user_manual/tutorials/software/aspect_ratio/","text":"The FunKey S provides 2 ways to to allow in-game change of the display aspect ratio: Using quick shortcuts Using the FunKey menu Quick shortcuts \u00b6 + : Change Aspect Ratio (AR), cycle between: Stretched (default) Cropped Scaled Manual Zoom + : Decrease zoom level by 10% + : Increase Zoom level by 10% FunKey menu \u00b6 Press the key to enter the FunKey menu Press the or key to select the \" ASPECT RATIO \" setting Use the and keys to change the aspect ratio Display Aspect Ratio Stretched (default): The display is stretched horizontally and vertically to fill the screen in both directions Cropped (Zoom 100%), The display fills the screen vertically, and is clipped vertically to the left and right of the screen Scaled (Zoom 0%): The display is scaled down in both directions to be fully visible, both horizontally and vertically Manual zoom: The display is zoomed in/out manually Press the key again to exit from the FunKey menu Aspect ratio preview \u00b6 Here is a short preview of what the different aspect ratios look like: Display Aspect Ratio Stretched (default): The display is stretched horizontally and vertically to fill the screen in both directions Cropped (Zoom 100%): The display fills the screen vertically, and is clipped vertically to the left and right of the screen Scaled (Zoom 0%): The display is scaled down in both directions to be fully visible, both horizontally and vertically Manual zoom 0% (Scaled): The display is scaled down in both directions to be fully visible, both horizontally and vertically Manual zoom 10% Manual zoom 20% Manual zoom 30% Manual zoom 40% Manual zoom 50% (default zoom level) Manual zoom 60% Manual zoom 70% Manual zoom 80% Manual zoom 90% Manual zoom 100% (Cropped): The display fills the screen vertically, and is clipped vertically to the left and right of the screen","title":"Change Aspect Ratio"},{"location":"user_manual/tutorials/software/aspect_ratio/#quick-shortcuts","text":"+ : Change Aspect Ratio (AR), cycle between: Stretched (default) Cropped Scaled Manual Zoom + : Decrease zoom level by 10% + : Increase Zoom level by 10%","title":"Quick shortcuts"},{"location":"user_manual/tutorials/software/aspect_ratio/#funkey-menu","text":"Press the key to enter the FunKey menu Press the or key to select the \" ASPECT RATIO \" setting Use the and keys to change the aspect ratio Display Aspect Ratio Stretched (default): The display is stretched horizontally and vertically to fill the screen in both directions Cropped (Zoom 100%), The display fills the screen vertically, and is clipped vertically to the left and right of the screen Scaled (Zoom 0%): The display is scaled down in both directions to be fully visible, both horizontally and vertically Manual zoom: The display is zoomed in/out manually Press the key again to exit from the FunKey menu","title":"FunKey menu"},{"location":"user_manual/tutorials/software/aspect_ratio/#aspect-ratio-preview","text":"Here is a short preview of what the different aspect ratios look like: Display Aspect Ratio Stretched (default): The display is stretched horizontally and vertically to fill the screen in both directions Cropped (Zoom 100%): The display fills the screen vertically, and is clipped vertically to the left and right of the screen Scaled (Zoom 0%): The display is scaled down in both directions to be fully visible, both horizontally and vertically Manual zoom 0% (Scaled): The display is scaled down in both directions to be fully visible, both horizontally and vertically Manual zoom 10% Manual zoom 20% Manual zoom 30% Manual zoom 40% Manual zoom 50% (default zoom level) Manual zoom 60% Manual zoom 70% Manual zoom 80% Manual zoom 90% Manual zoom 100% (Cropped): The display fills the screen vertically, and is clipped vertically to the left and right of the screen","title":"Aspect ratio preview"},{"location":"user_manual/tutorials/software/firmware_update/","text":"A firmware upgrade can be performed simply over USB without opening the FunKey S console. Get the latest \" FunKey-rootfs-x.y.z.fwu \" firmware update file directly from here or from the bottom of the latest release page in the \"assets\" section: https://github.com/FunKey-Project/FunKey-OS/releases/latest Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop the ***FunKey-rootfs-x.y.z.fwu file you just downloaded at the root of this USB drive on your computer Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm The FunKey S will then reboot and perform the upgrade","title":"Firmware Upgrade"},{"location":"user_manual/tutorials/software/gb_palette/","text":"Palette Description \u00b6 The default FunKey S Game Boy emulator: gnuboy allows to set the palette used for grayscale when running DMG (original mono Gameboy) ROMs. There are four variables for this purpose, allowing the background, window, and both sprite palettes to be colored differently. Each one is made up of four numbers, the color to use for each shade of gray, from lightest to darkest. Colors are represented as 24-bit hexadecimal numbers, with red component in the low (rightmost) 2 digits, green component in the middle 2 digits and blue component in the upper (leftmost) 2 digits. For example, to set the background to shades of white, the window to shades of red, and the sprite palettes to shades of green and blue, you could use: set dmg_bgp 0xffffff 0xaaaaaa 0x555555 0x000000 set dmg_wndp 0x0000ff 0x0000aa 0x000055 0x000000 set dmg_obp0 0x00ff00 0x00aa00 0x005500 0x000000 set dmg_obp1 0xff0000 0xaa0000 0x550000 0x000000 This will of course look rather ugly, but it does the job illustrating how you set various colors. Here is a list of example palettes proposed by the gnuboy emulator: # Default palette used in the FunKey S. set dmg_bgp 0x98d0e0 0x68a0b0 0x60707C 0x2C3C3C set dmg_wndp 0x98d0e0 0x68a0b0 0x60707C 0x2C3C3C set dmg_obp0 0x98d0e0 0x68a0b0 0x60707C 0x2C3C3C set dmg_obp1 0x98d0e0 0x68a0b0 0x60707C 0x2C3C3C # Old default palette from 0.8.0 thru 0.9.13. # This was designed for use on a laptop display, # so it's probably way too yellowish. set dmg_bgp 0x78f0f0 0x58b8b8 0x487878 0x184848 set dmg_wndp 0x78f0f0 0x58b8b8 0x487878 0x184848 set dmg_obp0 0x78f0f0 0x58b8b8 0x487878 0x184848 set dmg_obp1 0x78f0f0 0x58b8b8 0x487878 0x184848 # Old dim grayscale. set dmg_bgp 0xc0c0c0 0x808080 0x404040 0x000000 set dmg_wndp 0xc0c0c0 0x808080 0x404040 0x000000 set dmg_obp0 0xc0c0c0 0x808080 0x404040 0x000000 set dmg_obp1 0xc0c0c0 0x808080 0x404040 0x000000 # Light grayscale. set dmg_bgp 0xffffff 0xc0c0c0 0x808080 0x404040 set dmg_wndp 0xffffff 0xc0c0c0 0x808080 0x404040 set dmg_obp0 0xffffff 0xc0c0c0 0x808080 0x404040 set dmg_obp1 0xffffff 0xc0c0c0 0x808080 0x404040 # Full contrast grayscale. set dmg_bgp 0xffffff 0xaaaaaa 0x555555 0x000000 set dmg_wndp 0xffffff 0xaaaaaa 0x555555 0x000000 set dmg_obp0 0xffffff 0xaaaaaa 0x555555 0x000000 set dmg_obp1 0xffffff 0xaaaaaa 0x555555 0x000000 # Debug palette. # Each of the four layers is colored differently, # making it easier to debug visual glitches in # roms that use them all together cleverly. set dmg_bgp 0xf898c8 0xf83098 0xc80060 0x600030 set dmg_wndp 0xd0c0c0 0xa88080 0x785050 0x382828 set dmg_obp0 0x9898f8 0x3030f8 0x0000c8 0x000060 set dmg_obp1 0xc8f898 0x98f830 0x60c800 0x306000 # Sprites standout. # Similar to above, but the colors are more subdued and # the window and background are the same. This palette # may actually be suitable for playing some games... set dmg_bgp 0xd0c0c0 0xa88080 0x785050 0x382828 set dmg_wndp 0xd0c0c0 0xa88080 0x785050 0x382828 set dmg_obp0 0xc8e0f8 0x90a8e8 0x4878a8 0x183850 set dmg_obp1 0x98b8f8 0x3050f8 0x2040a8 0x002060 # LCD yellows and grays. # An earlier version of the new default palette. set dmg_bgp 0x88e0f0 0x68a8b8 0x586878 0x283838 set dmg_wndp 0x88e0f0 0x68a8b8 0x586878 0x283838 set dmg_obp0 0x88e0f0 0x68a8b8 0x586878 0x283838 set dmg_obp1 0x88e0f0 0x68a8b8 0x586878 0x283838 # LCD yellowscale. # And another similar one. set dmg_bgp 0x88e0f0 0x68a8b8 0x486878 0x203838 set dmg_wndp 0x88e0f0 0x68a8b8 0x486878 0x203838 set dmg_obp0 0x88e0f0 0x68a8b8 0x486878 0x203838 set dmg_obp1 0x88e0f0 0x68a8b8 0x486878 0x203838 # Slightly colorful. # Not just a plain lightness gradient, but some # change in hue as well. Looks ok with some games; # designed in particular for the FFL series. set dmg_bgp 0x98e0f8 0x78a0c0 0x747080 0x604038 set dmg_wndp 0x98e0f8 0x78a0c0 0x747080 0x604038 set dmg_obp0 0x98e0f8 0x78a0c0 0x747080 0x604038 set dmg_obp1 0x98e0f8 0x78a0c0 0x747080 0x604038 # Optionally use these with the above palette to # make sprites stand out a bit. set dmg_obp0 0x98e0f8 0x5090c0 0x507898 0x583838 set dmg_obp1 0x98e0f8 0x5090c0 0x686078 0x383838 # R-Type 1 palette from R-Type DX set dmg_bgp 0xc0ffff 0x408080 0x204040 0x000000 set dmg_wndp 0xc0ffff 0x408080 0x204040 0x000000 set dmg_obp0 0xc0ffff 0x408080 0x204040 0x000000 set dmg_obp1 0xc0ffff 0x408080 0x204040 0x000000` Changing the Palette \u00b6 Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) In the FunKey folder, create a new folder .gnuboy if it does not already exist. In the FunKey/.gnuboy folder create a file gnuboy.rc if it does not already exist. Open the gnuboy.rc file with a text editor and add the palette you want. Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen Launch any Gameboy game to see the results of your new palette settings.","title":"Change Gameboy Palette"},{"location":"user_manual/tutorials/software/gb_palette/#palette-description","text":"The default FunKey S Game Boy emulator: gnuboy allows to set the palette used for grayscale when running DMG (original mono Gameboy) ROMs. There are four variables for this purpose, allowing the background, window, and both sprite palettes to be colored differently. Each one is made up of four numbers, the color to use for each shade of gray, from lightest to darkest. Colors are represented as 24-bit hexadecimal numbers, with red component in the low (rightmost) 2 digits, green component in the middle 2 digits and blue component in the upper (leftmost) 2 digits. For example, to set the background to shades of white, the window to shades of red, and the sprite palettes to shades of green and blue, you could use: set dmg_bgp 0xffffff 0xaaaaaa 0x555555 0x000000 set dmg_wndp 0x0000ff 0x0000aa 0x000055 0x000000 set dmg_obp0 0x00ff00 0x00aa00 0x005500 0x000000 set dmg_obp1 0xff0000 0xaa0000 0x550000 0x000000 This will of course look rather ugly, but it does the job illustrating how you set various colors. Here is a list of example palettes proposed by the gnuboy emulator: # Default palette used in the FunKey S. set dmg_bgp 0x98d0e0 0x68a0b0 0x60707C 0x2C3C3C set dmg_wndp 0x98d0e0 0x68a0b0 0x60707C 0x2C3C3C set dmg_obp0 0x98d0e0 0x68a0b0 0x60707C 0x2C3C3C set dmg_obp1 0x98d0e0 0x68a0b0 0x60707C 0x2C3C3C # Old default palette from 0.8.0 thru 0.9.13. # This was designed for use on a laptop display, # so it's probably way too yellowish. set dmg_bgp 0x78f0f0 0x58b8b8 0x487878 0x184848 set dmg_wndp 0x78f0f0 0x58b8b8 0x487878 0x184848 set dmg_obp0 0x78f0f0 0x58b8b8 0x487878 0x184848 set dmg_obp1 0x78f0f0 0x58b8b8 0x487878 0x184848 # Old dim grayscale. set dmg_bgp 0xc0c0c0 0x808080 0x404040 0x000000 set dmg_wndp 0xc0c0c0 0x808080 0x404040 0x000000 set dmg_obp0 0xc0c0c0 0x808080 0x404040 0x000000 set dmg_obp1 0xc0c0c0 0x808080 0x404040 0x000000 # Light grayscale. set dmg_bgp 0xffffff 0xc0c0c0 0x808080 0x404040 set dmg_wndp 0xffffff 0xc0c0c0 0x808080 0x404040 set dmg_obp0 0xffffff 0xc0c0c0 0x808080 0x404040 set dmg_obp1 0xffffff 0xc0c0c0 0x808080 0x404040 # Full contrast grayscale. set dmg_bgp 0xffffff 0xaaaaaa 0x555555 0x000000 set dmg_wndp 0xffffff 0xaaaaaa 0x555555 0x000000 set dmg_obp0 0xffffff 0xaaaaaa 0x555555 0x000000 set dmg_obp1 0xffffff 0xaaaaaa 0x555555 0x000000 # Debug palette. # Each of the four layers is colored differently, # making it easier to debug visual glitches in # roms that use them all together cleverly. set dmg_bgp 0xf898c8 0xf83098 0xc80060 0x600030 set dmg_wndp 0xd0c0c0 0xa88080 0x785050 0x382828 set dmg_obp0 0x9898f8 0x3030f8 0x0000c8 0x000060 set dmg_obp1 0xc8f898 0x98f830 0x60c800 0x306000 # Sprites standout. # Similar to above, but the colors are more subdued and # the window and background are the same. This palette # may actually be suitable for playing some games... set dmg_bgp 0xd0c0c0 0xa88080 0x785050 0x382828 set dmg_wndp 0xd0c0c0 0xa88080 0x785050 0x382828 set dmg_obp0 0xc8e0f8 0x90a8e8 0x4878a8 0x183850 set dmg_obp1 0x98b8f8 0x3050f8 0x2040a8 0x002060 # LCD yellows and grays. # An earlier version of the new default palette. set dmg_bgp 0x88e0f0 0x68a8b8 0x586878 0x283838 set dmg_wndp 0x88e0f0 0x68a8b8 0x586878 0x283838 set dmg_obp0 0x88e0f0 0x68a8b8 0x586878 0x283838 set dmg_obp1 0x88e0f0 0x68a8b8 0x586878 0x283838 # LCD yellowscale. # And another similar one. set dmg_bgp 0x88e0f0 0x68a8b8 0x486878 0x203838 set dmg_wndp 0x88e0f0 0x68a8b8 0x486878 0x203838 set dmg_obp0 0x88e0f0 0x68a8b8 0x486878 0x203838 set dmg_obp1 0x88e0f0 0x68a8b8 0x486878 0x203838 # Slightly colorful. # Not just a plain lightness gradient, but some # change in hue as well. Looks ok with some games; # designed in particular for the FFL series. set dmg_bgp 0x98e0f8 0x78a0c0 0x747080 0x604038 set dmg_wndp 0x98e0f8 0x78a0c0 0x747080 0x604038 set dmg_obp0 0x98e0f8 0x78a0c0 0x747080 0x604038 set dmg_obp1 0x98e0f8 0x78a0c0 0x747080 0x604038 # Optionally use these with the above palette to # make sprites stand out a bit. set dmg_obp0 0x98e0f8 0x5090c0 0x507898 0x583838 set dmg_obp1 0x98e0f8 0x5090c0 0x686078 0x383838 # R-Type 1 palette from R-Type DX set dmg_bgp 0xc0ffff 0x408080 0x204040 0x000000 set dmg_wndp 0xc0ffff 0x408080 0x204040 0x000000 set dmg_obp0 0xc0ffff 0x408080 0x204040 0x000000 set dmg_obp1 0xc0ffff 0x408080 0x204040 0x000000`","title":"Palette Description"},{"location":"user_manual/tutorials/software/gb_palette/#changing-the-palette","text":"Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) In the FunKey folder, create a new folder .gnuboy if it does not already exist. In the FunKey/.gnuboy folder create a file gnuboy.rc if it does not already exist. Open the gnuboy.rc file with a text editor and add the palette you want. Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen Launch any Gameboy game to see the results of your new palette settings.","title":"Changing the Palette"},{"location":"user_manual/tutorials/software/gba_bios/","text":"Most retro-gaming console software emulators are able to run game ROMs directly. However, the Game Boy Advance an PS1 emulators do require an additional BIOS file in order to emulate all or some of the game ROMs. GBA \u00b6 If you launch a GBA game for the first time, you will get this screen: This means that you will need to install on the FunKey S a BIOS file with the right name, size and MD5 checksum before you can actually play. BIOS file name: gba_bios.bin MD5: a860e8c0b6d573d191e4ec7d Installation procedure \u00b6 Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop the gba_bios.bin BIOS file into the Game Boy Advance folder in this USB drive on your computer Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen PS1 \u00b6 As for the GBA, if you launch a PS1 game for the first time, you will get this screen: This means that you will need to install on the FunKey S a BIOS file with the right name and size before you can actually play. BIOS file name: SCPH1001.BIN Installation procedure \u00b6 Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop the SCPH1001.BIN BIOS file into the PS1/bios folder in this USB drive on your computer Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen","title":"Install the GBA/PS1 BIOS"},{"location":"user_manual/tutorials/software/gba_bios/#gba","text":"If you launch a GBA game for the first time, you will get this screen: This means that you will need to install on the FunKey S a BIOS file with the right name, size and MD5 checksum before you can actually play. BIOS file name: gba_bios.bin MD5: a860e8c0b6d573d191e4ec7d","title":"GBA"},{"location":"user_manual/tutorials/software/gba_bios/#installation-procedure","text":"Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop the gba_bios.bin BIOS file into the Game Boy Advance folder in this USB drive on your computer Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen","title":"Installation procedure"},{"location":"user_manual/tutorials/software/gba_bios/#ps1","text":"As for the GBA, if you launch a PS1 game for the first time, you will get this screen: This means that you will need to install on the FunKey S a BIOS file with the right name and size before you can actually play. BIOS file name: SCPH1001.BIN","title":"PS1"},{"location":"user_manual/tutorials/software/gba_bios/#installation-procedure_1","text":"Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop the SCPH1001.BIN BIOS file into the PS1/bios folder in this USB drive on your computer Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen","title":"Installation procedure"},{"location":"user_manual/tutorials/software/gmenu2x_wallpaper/","text":"Changing the Gmenu2x wallpaper is easy: the chosen picture must be a PNG file with a 240x240 pixel resolution. Connect your FunKey S console to your computer and add wallpaper files as simply as you would do it with a simple USB memory stick: Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with gmenu2x), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Navigate to the FunKey/.gmenu2x/skins/240x240/Default/wallpapers folder in this USB drive If they do not exist already, create the required folders hierarchically Drag & drop the wallpapers file into this folder Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen Navigate to the Settings tab using the or keys, select the Wallpaper icon using the , , or keys, then press the key Choose the wallpaper using the , , , , or keys, then press the key The selected wallpaper becomes the new gmenu2x wallpaper Of course, you can remove wallpaper files from the FunKey S console as you would do with a USB memory stick, too! The wallpaper is copyright \u00a9 2020 kiks_way .","title":"Change Gmenu2x Wallpaper"},{"location":"user_manual/tutorials/software/snapshot/","text":"The FunKey S allows to take in-game snapshots using a simple shortcut: just press the Fn + UP keys simultaneously. The snapshot files will be located in the FunKey/snapshots folder on the host computer and they will be numbered following a \" IMG_nnnn.PNG \" pattern, with \" nnnn \" being a number starting at 0001 and up to 9999. In order to access the snapshots, follow these simple steps: Display Action Connect the FunKey S to your computer using the provided micro USB cable, then open it to turn it on At the launcher's main screen (example here with RetroFE), press the key Press the or keys until you see \" MOUNT USB \" Press the key twice to confirm \" EJECT USB \" is now displayed instead, now go to your host computer and open a File Explorer window You should see the FunKey S appear as an USB drive on your computer in the File Explorer (example here with Windows 10) Drag & drop / Copy / Move / Delete the snapshots files from the FunKey/snapshots/ folder in this USB drive on your computer as required Eject cleanly the USB drive from your computer Back on the FunKey S , at the \" EJECT USB \" menu entry, press the key twice to confirm Press the key to return to the launcher screen","title":"Take a Snapshot"}]}